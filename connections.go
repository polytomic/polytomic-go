// This file was auto-generated by Fern from our API Definition.

package polytomic

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/polytomic/polytomic-go/core"
)

type ConnectCardRequest struct {
	Connection     *string  `json:"connection,omitempty" url:"connection,omitempty"`
	Name           string   `json:"name" url:"name"`
	OrganizationId *string  `json:"organization_id,omitempty" url:"organization_id,omitempty"`
	RedirectUrl    string   `json:"redirect_url" url:"redirect_url"`
	Type           *string  `json:"type,omitempty" url:"type,omitempty"`
	Whitelist      []string `json:"whitelist,omitempty" url:"whitelist,omitempty"`
}

type CreateConnectionRequestSchema struct {
	Configuration  map[string]interface{} `json:"configuration,omitempty" url:"configuration,omitempty"`
	Name           string                 `json:"name" url:"name"`
	OrganizationId *string                `json:"organization_id,omitempty" url:"organization_id,omitempty"`
	Policies       []string               `json:"policies,omitempty" url:"policies,omitempty"`
	// URL to redirect to after completing OAuth flow.
	RedirectUrl *string `json:"redirect_url,omitempty" url:"redirect_url,omitempty"`
	Type        string  `json:"type" url:"type"`
	// Validate connection configuration.
	Validate *bool `json:"validate,omitempty" url:"validate,omitempty"`
}

type ConnectionsRemoveRequest struct {
	Force *bool `json:"-" url:"force,omitempty"`
}

type UpdateConnectionRequestSchema struct {
	Configuration  map[string]interface{} `json:"configuration,omitempty" url:"configuration,omitempty"`
	Name           string                 `json:"name" url:"name"`
	OrganizationId *string                `json:"organization_id,omitempty" url:"organization_id,omitempty"`
	Policies       []string               `json:"policies,omitempty" url:"policies,omitempty"`
	Reconnect      *bool                  `json:"reconnect,omitempty" url:"reconnect,omitempty"`
	Type           *string                `json:"type,omitempty" url:"type,omitempty"`
	// Validate connection configuration.
	Validate *bool `json:"validate,omitempty" url:"validate,omitempty"`
}

type ConnectCardResponse struct {
	RedirectUrl *string `json:"redirect_url,omitempty" url:"redirect_url,omitempty"`
	Token       *string `json:"token,omitempty" url:"token,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ConnectCardResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectCardResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectCardResponse(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectCardResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConnectCardResponseEnvelope struct {
	Data *ConnectCardResponse `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ConnectCardResponseEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectCardResponseEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectCardResponseEnvelope(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectCardResponseEnvelope) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConnectionListResponseEnvelope struct {
	Data []*ConnectionResponseSchema `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ConnectionListResponseEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectionListResponseEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectionListResponseEnvelope(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionListResponseEnvelope) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConnectionParameterValue struct {
	Label *string     `json:"label,omitempty" url:"label,omitempty"`
	Value interface{} `json:"value,omitempty" url:"value,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ConnectionParameterValue) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectionParameterValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectionParameterValue(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionParameterValue) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConnectionParameterValuesResp struct {
	AllowsCreation *bool                       `json:"allows_creation,omitempty" url:"allows_creation,omitempty"`
	Values         []*ConnectionParameterValue `json:"values,omitempty" url:"values,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ConnectionParameterValuesResp) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectionParameterValuesResp
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectionParameterValuesResp(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionParameterValuesResp) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConnectionParameterValuesResponseEnvelope struct {
	Data map[string]*ConnectionParameterValuesResp `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ConnectionParameterValuesResponseEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectionParameterValuesResponseEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectionParameterValuesResponseEnvelope(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionParameterValuesResponseEnvelope) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConnectionResponseEnvelope struct {
	Data *ConnectionResponseSchema `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ConnectionResponseEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectionResponseEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectionResponseEnvelope(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionResponseEnvelope) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConnectionResponseSchema struct {
	// API calls made to service in the last 24h (supported integrations only).
	ApiCallsLast24Hours *int                   `json:"api_calls_last_24_hours,omitempty" url:"api_calls_last_24_hours,omitempty"`
	Configuration       map[string]interface{} `json:"configuration,omitempty" url:"configuration,omitempty"`
	Id                  *string                `json:"id,omitempty" url:"id,omitempty"`
	Name                *string                `json:"name,omitempty" url:"name,omitempty"`
	OrganizationId      *string                `json:"organization_id,omitempty" url:"organization_id,omitempty"`
	Policies            []string               `json:"policies,omitempty" url:"policies,omitempty"`
	Status              *string                `json:"status,omitempty" url:"status,omitempty"`
	StatusError         *string                `json:"status_error,omitempty" url:"status_error,omitempty"`
	Type                *ConnectionTypeSchema  `json:"type,omitempty" url:"type,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ConnectionResponseSchema) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectionResponseSchema
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectionResponseSchema(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionResponseSchema) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConnectionType struct {
	EnvConfig map[string]interface{} `json:"envConfig,omitempty" url:"envConfig,omitempty"`
	Id        *string                `json:"id,omitempty" url:"id,omitempty"`
	Name      *string                `json:"name,omitempty" url:"name,omitempty"`
	UseOauth  *bool                  `json:"use_oauth,omitempty" url:"use_oauth,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ConnectionType) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectionType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectionType(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionType) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConnectionTypeResponseEnvelope struct {
	Data []*ConnectionType `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ConnectionTypeResponseEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectionTypeResponseEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectionTypeResponseEnvelope(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionTypeResponseEnvelope) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConnectionTypeSchema struct {
	Id         *string  `json:"id,omitempty" url:"id,omitempty"`
	Name       *string  `json:"name,omitempty" url:"name,omitempty"`
	Operations []string `json:"operations,omitempty" url:"operations,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ConnectionTypeSchema) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectionTypeSchema
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectionTypeSchema(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionTypeSchema) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateConnectionResponseEnvelope struct {
	Data *CreateConnectionResponseSchema `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CreateConnectionResponseEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateConnectionResponseEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateConnectionResponseEnvelope(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateConnectionResponseEnvelope) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateConnectionResponseSchema struct {
	// Code to enter in order to complete connection authentication.
	AuthCode *string `json:"auth_code,omitempty" url:"auth_code,omitempty"`
	// URL to visit to complete connection authentication.
	AuthUrl        *string                `json:"auth_url,omitempty" url:"auth_url,omitempty"`
	Configuration  map[string]interface{} `json:"configuration,omitempty" url:"configuration,omitempty"`
	Id             *string                `json:"id,omitempty" url:"id,omitempty"`
	Name           *string                `json:"name,omitempty" url:"name,omitempty"`
	OrganizationId *string                `json:"organization_id,omitempty" url:"organization_id,omitempty"`
	Policies       []string               `json:"policies,omitempty" url:"policies,omitempty"`
	Status         *string                `json:"status,omitempty" url:"status,omitempty"`
	StatusError    *string                `json:"status_error,omitempty" url:"status_error,omitempty"`
	Type           *ConnectionTypeSchema  `json:"type,omitempty" url:"type,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CreateConnectionResponseSchema) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateConnectionResponseSchema
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateConnectionResponseSchema(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateConnectionResponseSchema) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type JsonschemaDefinitions = map[string]*JsonschemaSchema

type JsonschemaSchema struct {
	Anchor               *string                                             `json:"$anchor,omitempty" url:"$anchor,omitempty"`
	Comment              *string                                             `json:"$comment,omitempty" url:"$comment,omitempty"`
	Defs                 *JsonschemaDefinitions                              `json:"$defs,omitempty" url:"$defs,omitempty"`
	DynamicRef           *string                                             `json:"$dynamicRef,omitempty" url:"$dynamicRef,omitempty"`
	Id                   *string                                             `json:"$id,omitempty" url:"$id,omitempty"`
	Ref                  *string                                             `json:"$ref,omitempty" url:"$ref,omitempty"`
	Schema               *string                                             `json:"$schema,omitempty" url:"$schema,omitempty"`
	AdditionalProperties *JsonschemaSchema                                   `json:"additionalProperties,omitempty" url:"additionalProperties,omitempty"`
	AllOf                []*JsonschemaSchema                                 `json:"allOf,omitempty" url:"allOf,omitempty"`
	AnyOf                []*JsonschemaSchema                                 `json:"anyOf,omitempty" url:"anyOf,omitempty"`
	Const                interface{}                                         `json:"const,omitempty" url:"const,omitempty"`
	Contains             *JsonschemaSchema                                   `json:"contains,omitempty" url:"contains,omitempty"`
	ContentEncoding      *string                                             `json:"contentEncoding,omitempty" url:"contentEncoding,omitempty"`
	ContentMediaType     *string                                             `json:"contentMediaType,omitempty" url:"contentMediaType,omitempty"`
	ContentSchema        *JsonschemaSchema                                   `json:"contentSchema,omitempty" url:"contentSchema,omitempty"`
	Default              interface{}                                         `json:"default,omitempty" url:"default,omitempty"`
	DependentRequired    map[string][]string                                 `json:"dependentRequired,omitempty" url:"dependentRequired,omitempty"`
	DependentSchemas     map[string]*JsonschemaSchema                        `json:"dependentSchemas,omitempty" url:"dependentSchemas,omitempty"`
	Deprecated           *bool                                               `json:"deprecated,omitempty" url:"deprecated,omitempty"`
	Description          *string                                             `json:"description,omitempty" url:"description,omitempty"`
	Else                 *JsonschemaSchema                                   `json:"else,omitempty" url:"else,omitempty"`
	Enum                 []interface{}                                       `json:"enum,omitempty" url:"enum,omitempty"`
	Examples             []interface{}                                       `json:"examples,omitempty" url:"examples,omitempty"`
	ExclusiveMaximum     *string                                             `json:"exclusiveMaximum,omitempty" url:"exclusiveMaximum,omitempty"`
	ExclusiveMinimum     *string                                             `json:"exclusiveMinimum,omitempty" url:"exclusiveMinimum,omitempty"`
	Format               *string                                             `json:"format,omitempty" url:"format,omitempty"`
	If                   *JsonschemaSchema                                   `json:"if,omitempty" url:"if,omitempty"`
	Items                *JsonschemaSchema                                   `json:"items,omitempty" url:"items,omitempty"`
	MaxContains          *int                                                `json:"maxContains,omitempty" url:"maxContains,omitempty"`
	MaxItems             *int                                                `json:"maxItems,omitempty" url:"maxItems,omitempty"`
	MaxLength            *int                                                `json:"maxLength,omitempty" url:"maxLength,omitempty"`
	MaxProperties        *int                                                `json:"maxProperties,omitempty" url:"maxProperties,omitempty"`
	Maximum              *string                                             `json:"maximum,omitempty" url:"maximum,omitempty"`
	MinContains          *int                                                `json:"minContains,omitempty" url:"minContains,omitempty"`
	MinItems             *int                                                `json:"minItems,omitempty" url:"minItems,omitempty"`
	MinLength            *int                                                `json:"minLength,omitempty" url:"minLength,omitempty"`
	MinProperties        *int                                                `json:"minProperties,omitempty" url:"minProperties,omitempty"`
	Minimum              *string                                             `json:"minimum,omitempty" url:"minimum,omitempty"`
	MultipleOf           *string                                             `json:"multipleOf,omitempty" url:"multipleOf,omitempty"`
	Not                  *JsonschemaSchema                                   `json:"not,omitempty" url:"not,omitempty"`
	OneOf                []*JsonschemaSchema                                 `json:"oneOf,omitempty" url:"oneOf,omitempty"`
	Pattern              *string                                             `json:"pattern,omitempty" url:"pattern,omitempty"`
	PatternProperties    map[string]*JsonschemaSchema                        `json:"patternProperties,omitempty" url:"patternProperties,omitempty"`
	PrefixItems          []*JsonschemaSchema                                 `json:"prefixItems,omitempty" url:"prefixItems,omitempty"`
	Properties           *V2OrderedMapStringGithubComInvopopJsonschemaSchema `json:"properties,omitempty" url:"properties,omitempty"`
	PropertyNames        *JsonschemaSchema                                   `json:"propertyNames,omitempty" url:"propertyNames,omitempty"`
	ReadOnly             *bool                                               `json:"readOnly,omitempty" url:"readOnly,omitempty"`
	Required             []string                                            `json:"required,omitempty" url:"required,omitempty"`
	Then                 *JsonschemaSchema                                   `json:"then,omitempty" url:"then,omitempty"`
	Title                *string                                             `json:"title,omitempty" url:"title,omitempty"`
	Type                 *string                                             `json:"type,omitempty" url:"type,omitempty"`
	UniqueItems          *bool                                               `json:"uniqueItems,omitempty" url:"uniqueItems,omitempty"`
	WriteOnly            *bool                                               `json:"writeOnly,omitempty" url:"writeOnly,omitempty"`

	_rawJSON json.RawMessage
}

func (j *JsonschemaSchema) UnmarshalJSON(data []byte) error {
	type unmarshaler JsonschemaSchema
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JsonschemaSchema(value)
	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JsonschemaSchema) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type V2OrderedMapStringGithubComInvopopJsonschemaSchema = map[string]interface{}
