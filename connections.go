// This file was auto-generated by Fern from our API Definition.

package polytomic

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/polytomic/polytomic-go/core"
	time "time"
)

type ConnectCardRequest struct {
	// The id of an existing connection to update.
	Connection *string `json:"connection,omitempty" url:"connection,omitempty"`
	// Whether to use the dark theme for the Connect modal.
	Dark *bool `json:"dark,omitempty" url:"dark,omitempty"`
	// Name of the new connection. Must be unique per organization.
	Name           string  `json:"name" url:"name"`
	OrganizationID *string `json:"organization_id,omitempty" url:"organization_id,omitempty"`
	// URL to redirect to after connection is created.
	RedirectURL string `json:"redirect_url" url:"redirect_url"`
	// Connection type to create.
	Type *string `json:"type,omitempty" url:"type,omitempty"`
	// List of connection types which are allowed to be created. Ignored if type is set.
	Whitelist []string `json:"whitelist,omitempty" url:"whitelist,omitempty"`
}

type CreateConnectionRequestSchema struct {
	Configuration map[string]interface{} `json:"configuration,omitempty" url:"configuration,omitempty"`
	// Override interval for connection health checking.
	HealthcheckInterval *string  `json:"healthcheck_interval,omitempty" url:"healthcheck_interval,omitempty"`
	Name                string   `json:"name" url:"name"`
	OrganizationID      *string  `json:"organization_id,omitempty" url:"organization_id,omitempty"`
	Policies            []string `json:"policies,omitempty" url:"policies,omitempty"`
	// URL to redirect to after completing OAuth flow.
	RedirectURL *string `json:"redirect_url,omitempty" url:"redirect_url,omitempty"`
	Type        string  `json:"type" url:"type"`
	// Validate connection configuration.
	Validate *bool `json:"validate,omitempty" url:"validate,omitempty"`
}

type ConnectionsGetRequest struct {
}

type ConnectionsGetConnectionTypeSchemaRequest struct {
}

type ConnectionsGetParameterValuesRequest struct {
}

type ConnectionsRemoveRequest struct {
	Force *bool `json:"-" url:"force,omitempty"`
}

type TestConnectionRequest struct {
	// Connection configuration to test.
	Configuration map[string]interface{} `json:"configuration,omitempty" url:"configuration,omitempty"`
	// Optional existing connection ID to use as a base for testing. The provided configuration will be merged over the stored configuration for this connection before testing.
	ConnectionID *string `json:"connection_id,omitempty" url:"connection_id,omitempty"`
	// The type of connection to test.
	Type string `json:"type" url:"type"`
}

type UpdateConnectionRequestSchema struct {
	Configuration map[string]interface{} `json:"configuration,omitempty" url:"configuration,omitempty"`
	// Override interval for connection health checking.
	HealthcheckInterval *string  `json:"healthcheck_interval,omitempty" url:"healthcheck_interval,omitempty"`
	Name                string   `json:"name" url:"name"`
	OrganizationID      *string  `json:"organization_id,omitempty" url:"organization_id,omitempty"`
	Policies            []string `json:"policies,omitempty" url:"policies,omitempty"`
	Reconnect           *bool    `json:"reconnect,omitempty" url:"reconnect,omitempty"`
	Type                *string  `json:"type,omitempty" url:"type,omitempty"`
	// Validate connection configuration.
	Validate *bool `json:"validate,omitempty" url:"validate,omitempty"`
}

type BackendConnectionCapabilities struct {
	Destination   bool `json:"destination" url:"destination"`
	Enrichment    bool `json:"enrichment" url:"enrichment"`
	Orchestration bool `json:"orchestration" url:"orchestration"`
	Source        bool `json:"source" url:"source"`

	_rawJSON json.RawMessage
}

func (b *BackendConnectionCapabilities) UnmarshalJSON(data []byte) error {
	type unmarshaler BackendConnectionCapabilities
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BackendConnectionCapabilities(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BackendConnectionCapabilities) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BackendOAuthPrompt struct {
	Key   *string `json:"key,omitempty" url:"key,omitempty"`
	Value *string `json:"value,omitempty" url:"value,omitempty"`
	When  *string `json:"when,omitempty" url:"when,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BackendOAuthPrompt) UnmarshalJSON(data []byte) error {
	type unmarshaler BackendOAuthPrompt
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BackendOAuthPrompt(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BackendOAuthPrompt) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type ConnectCardResponse struct {
	// URL to redirect the user to in order to create the new connection.
	RedirectURL *string `json:"redirect_url,omitempty" url:"redirect_url,omitempty"`
	Token       *string `json:"token,omitempty" url:"token,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ConnectCardResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectCardResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectCardResponse(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectCardResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConnectCardResponseEnvelope struct {
	Data *ConnectCardResponse `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ConnectCardResponseEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectCardResponseEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectCardResponseEnvelope(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectCardResponseEnvelope) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConnectionListResponseEnvelope struct {
	Data []*ConnectionResponseSchema `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ConnectionListResponseEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectionListResponseEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectionListResponseEnvelope(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionListResponseEnvelope) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConnectionParameterValue struct {
	Label *string     `json:"label,omitempty" url:"label,omitempty"`
	Value interface{} `json:"value,omitempty" url:"value,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ConnectionParameterValue) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectionParameterValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectionParameterValue(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionParameterValue) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConnectionParameterValuesResp struct {
	AllowsCreation *bool                       `json:"allows_creation,omitempty" url:"allows_creation,omitempty"`
	Values         []*ConnectionParameterValue `json:"values,omitempty" url:"values,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ConnectionParameterValuesResp) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectionParameterValuesResp
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectionParameterValuesResp(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionParameterValuesResp) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConnectionParameterValuesResponseEnvelope struct {
	Data map[string]*ConnectionParameterValuesResp `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ConnectionParameterValuesResponseEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectionParameterValuesResponseEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectionParameterValuesResponseEnvelope(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionParameterValuesResponseEnvelope) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConnectionResponseEnvelope struct {
	Data *ConnectionResponseSchema `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ConnectionResponseEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectionResponseEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectionResponseEnvelope(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionResponseEnvelope) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConnectionResponseSchema struct {
	// API calls made to service in the last 24h (supported integrations only).
	APICallsLast24Hours *int                   `json:"api_calls_last_24_hours,omitempty" url:"api_calls_last_24_hours,omitempty"`
	Configuration       map[string]interface{} `json:"configuration,omitempty" url:"configuration,omitempty"`
	CreatedAt           *time.Time             `json:"created_at,omitempty" url:"created_at,omitempty"`
	CreatedBy           *CommonOutputActor     `json:"created_by,omitempty" url:"created_by,omitempty"`
	ID                  *string                `json:"id,omitempty" url:"id,omitempty"`
	Name                *string                `json:"name,omitempty" url:"name,omitempty"`
	OrganizationID      *string                `json:"organization_id,omitempty" url:"organization_id,omitempty"`
	Policies            []string               `json:"policies,omitempty" url:"policies,omitempty"`
	Saved               *bool                  `json:"saved,omitempty" url:"saved,omitempty"`
	Status              *string                `json:"status,omitempty" url:"status,omitempty"`
	StatusError         *string                `json:"status_error,omitempty" url:"status_error,omitempty"`
	Type                *ConnectionTypeSchema  `json:"type,omitempty" url:"type,omitempty"`
	UpdatedAt           *time.Time             `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	UpdatedBy           *CommonOutputActor     `json:"updated_by,omitempty" url:"updated_by,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ConnectionResponseSchema) UnmarshalJSON(data []byte) error {
	type embed ConnectionResponseSchema
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at,omitempty"`
		UpdatedAt *core.DateTime `json:"updated_at,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ConnectionResponseSchema(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	c.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionResponseSchema) MarshalJSON() ([]byte, error) {
	type embed ConnectionResponseSchema
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at,omitempty"`
		UpdatedAt *core.DateTime `json:"updated_at,omitempty"`
	}{
		embed:     embed(*c),
		CreatedAt: core.NewOptionalDateTime(c.CreatedAt),
		UpdatedAt: core.NewOptionalDateTime(c.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *ConnectionResponseSchema) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConnectionType struct {
	Capabilities         *BackendConnectionCapabilities `json:"capabilities,omitempty" url:"capabilities,omitempty"`
	ConfigurationForm    *V2ConnectionForm              `json:"configurationForm,omitempty" url:"configurationForm,omitempty"`
	EnvConfig            map[string]interface{}         `json:"envConfig,omitempty" url:"envConfig,omitempty"`
	ID                   *string                        `json:"id,omitempty" url:"id,omitempty"`
	InitialConfiguration map[string]interface{}         `json:"initialConfiguration,omitempty" url:"initialConfiguration,omitempty"`
	LogoURL              *string                        `json:"logo_url,omitempty" url:"logo_url,omitempty"`
	Name                 *string                        `json:"name,omitempty" url:"name,omitempty"`
	OauthPrompt          *BackendOAuthPrompt            `json:"oauth_prompt,omitempty" url:"oauth_prompt,omitempty"`
	UseOauth             *bool                          `json:"use_oauth,omitempty" url:"use_oauth,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ConnectionType) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectionType
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectionType(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionType) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConnectionTypeResponseEnvelope struct {
	Data []*ConnectionType `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ConnectionTypeResponseEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectionTypeResponseEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectionTypeResponseEnvelope(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionTypeResponseEnvelope) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConnectionTypeSchema struct {
	ID         *string  `json:"id,omitempty" url:"id,omitempty"`
	LogoURL    *string  `json:"logo_url,omitempty" url:"logo_url,omitempty"`
	Name       *string  `json:"name,omitempty" url:"name,omitempty"`
	Operations []string `json:"operations,omitempty" url:"operations,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ConnectionTypeSchema) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectionTypeSchema
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectionTypeSchema(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionTypeSchema) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateConnectionResponseEnvelope struct {
	Data *CreateConnectionResponseSchema `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CreateConnectionResponseEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateConnectionResponseEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateConnectionResponseEnvelope(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateConnectionResponseEnvelope) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateConnectionResponseSchema struct {
	// Code to enter in order to complete connection authentication.
	AuthCode *string `json:"auth_code,omitempty" url:"auth_code,omitempty"`
	// URL to visit to complete connection authentication.
	AuthURL       *string                `json:"auth_url,omitempty" url:"auth_url,omitempty"`
	Configuration map[string]interface{} `json:"configuration,omitempty" url:"configuration,omitempty"`
	// Interval for connection health checking.
	HealthcheckInterval *string               `json:"healthcheck_interval,omitempty" url:"healthcheck_interval,omitempty"`
	ID                  *string               `json:"id,omitempty" url:"id,omitempty"`
	Name                *string               `json:"name,omitempty" url:"name,omitempty"`
	OrganizationID      *string               `json:"organization_id,omitempty" url:"organization_id,omitempty"`
	Policies            []string              `json:"policies,omitempty" url:"policies,omitempty"`
	Saved               *bool                 `json:"saved,omitempty" url:"saved,omitempty"`
	Status              *string               `json:"status,omitempty" url:"status,omitempty"`
	StatusError         *string               `json:"status_error,omitempty" url:"status_error,omitempty"`
	Type                *ConnectionTypeSchema `json:"type,omitempty" url:"type,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CreateConnectionResponseSchema) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateConnectionResponseSchema
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateConnectionResponseSchema(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateConnectionResponseSchema) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type JsonschemaDefinitions = map[string]*JsonschemaSchema

type JsonschemaSchema struct {
	Anchor               *string                                             `json:"$anchor,omitempty" url:"$anchor,omitempty"`
	Comment              *string                                             `json:"$comment,omitempty" url:"$comment,omitempty"`
	Defs                 *JsonschemaDefinitions                              `json:"$defs,omitempty" url:"$defs,omitempty"`
	DynamicRef           *string                                             `json:"$dynamicRef,omitempty" url:"$dynamicRef,omitempty"`
	ID                   *string                                             `json:"$id,omitempty" url:"$id,omitempty"`
	Ref                  *string                                             `json:"$ref,omitempty" url:"$ref,omitempty"`
	Schema               *string                                             `json:"$schema,omitempty" url:"$schema,omitempty"`
	AdditionalProperties *JsonschemaSchema                                   `json:"additionalProperties,omitempty" url:"additionalProperties,omitempty"`
	AllOf                []*JsonschemaSchema                                 `json:"allOf,omitempty" url:"allOf,omitempty"`
	AnyOf                []*JsonschemaSchema                                 `json:"anyOf,omitempty" url:"anyOf,omitempty"`
	Const                interface{}                                         `json:"const,omitempty" url:"const,omitempty"`
	Contains             *JsonschemaSchema                                   `json:"contains,omitempty" url:"contains,omitempty"`
	ContentEncoding      *string                                             `json:"contentEncoding,omitempty" url:"contentEncoding,omitempty"`
	ContentMediaType     *string                                             `json:"contentMediaType,omitempty" url:"contentMediaType,omitempty"`
	ContentSchema        *JsonschemaSchema                                   `json:"contentSchema,omitempty" url:"contentSchema,omitempty"`
	Default              interface{}                                         `json:"default,omitempty" url:"default,omitempty"`
	DependentRequired    map[string][]string                                 `json:"dependentRequired,omitempty" url:"dependentRequired,omitempty"`
	DependentSchemas     map[string]*JsonschemaSchema                        `json:"dependentSchemas,omitempty" url:"dependentSchemas,omitempty"`
	Deprecated           *bool                                               `json:"deprecated,omitempty" url:"deprecated,omitempty"`
	Description          *string                                             `json:"description,omitempty" url:"description,omitempty"`
	Else                 *JsonschemaSchema                                   `json:"else,omitempty" url:"else,omitempty"`
	Enum                 []interface{}                                       `json:"enum,omitempty" url:"enum,omitempty"`
	Examples             []interface{}                                       `json:"examples,omitempty" url:"examples,omitempty"`
	ExclusiveMaximum     *string                                             `json:"exclusiveMaximum,omitempty" url:"exclusiveMaximum,omitempty"`
	ExclusiveMinimum     *string                                             `json:"exclusiveMinimum,omitempty" url:"exclusiveMinimum,omitempty"`
	Format               *string                                             `json:"format,omitempty" url:"format,omitempty"`
	If                   *JsonschemaSchema                                   `json:"if,omitempty" url:"if,omitempty"`
	Items                *JsonschemaSchema                                   `json:"items,omitempty" url:"items,omitempty"`
	MaxContains          *int                                                `json:"maxContains,omitempty" url:"maxContains,omitempty"`
	MaxItems             *int                                                `json:"maxItems,omitempty" url:"maxItems,omitempty"`
	MaxLength            *int                                                `json:"maxLength,omitempty" url:"maxLength,omitempty"`
	MaxProperties        *int                                                `json:"maxProperties,omitempty" url:"maxProperties,omitempty"`
	Maximum              *string                                             `json:"maximum,omitempty" url:"maximum,omitempty"`
	MinContains          *int                                                `json:"minContains,omitempty" url:"minContains,omitempty"`
	MinItems             *int                                                `json:"minItems,omitempty" url:"minItems,omitempty"`
	MinLength            *int                                                `json:"minLength,omitempty" url:"minLength,omitempty"`
	MinProperties        *int                                                `json:"minProperties,omitempty" url:"minProperties,omitempty"`
	Minimum              *string                                             `json:"minimum,omitempty" url:"minimum,omitempty"`
	MultipleOf           *string                                             `json:"multipleOf,omitempty" url:"multipleOf,omitempty"`
	Not                  *JsonschemaSchema                                   `json:"not,omitempty" url:"not,omitempty"`
	OneOf                []*JsonschemaSchema                                 `json:"oneOf,omitempty" url:"oneOf,omitempty"`
	Pattern              *string                                             `json:"pattern,omitempty" url:"pattern,omitempty"`
	PatternProperties    map[string]*JsonschemaSchema                        `json:"patternProperties,omitempty" url:"patternProperties,omitempty"`
	PrefixItems          []*JsonschemaSchema                                 `json:"prefixItems,omitempty" url:"prefixItems,omitempty"`
	Properties           *V2OrderedMapStringGithubComInvopopJsonschemaSchema `json:"properties,omitempty" url:"properties,omitempty"`
	PropertyNames        *JsonschemaSchema                                   `json:"propertyNames,omitempty" url:"propertyNames,omitempty"`
	ReadOnly             *bool                                               `json:"readOnly,omitempty" url:"readOnly,omitempty"`
	Required             []string                                            `json:"required,omitempty" url:"required,omitempty"`
	Then                 *JsonschemaSchema                                   `json:"then,omitempty" url:"then,omitempty"`
	Title                *string                                             `json:"title,omitempty" url:"title,omitempty"`
	Type                 *string                                             `json:"type,omitempty" url:"type,omitempty"`
	UniqueItems          *bool                                               `json:"uniqueItems,omitempty" url:"uniqueItems,omitempty"`
	WriteOnly            *bool                                               `json:"writeOnly,omitempty" url:"writeOnly,omitempty"`

	_rawJSON json.RawMessage
}

func (j *JsonschemaSchema) UnmarshalJSON(data []byte) error {
	type unmarshaler JsonschemaSchema
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JsonschemaSchema(value)
	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JsonschemaSchema) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type V2ConnectionForm struct {
	Jsonschema interface{} `json:"jsonschema,omitempty" url:"jsonschema,omitempty"`
	Uischema   interface{} `json:"uischema,omitempty" url:"uischema,omitempty"`

	_rawJSON json.RawMessage
}

func (v *V2ConnectionForm) UnmarshalJSON(data []byte) error {
	type unmarshaler V2ConnectionForm
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V2ConnectionForm(value)
	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V2ConnectionForm) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V2OrderedMapStringGithubComInvopopJsonschemaSchema = map[string]interface{}
