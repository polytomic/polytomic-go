// This file was auto-generated by Fern from our API Definition.

package polytomic

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/polytomic/polytomic-go/core"
	time "time"
)

type ModelSyncActivateRequest struct {
	Body *ActivateSyncInput `json:"-" url:"-"`
}

func (m *ModelSyncActivateRequest) UnmarshalJSON(data []byte) error {
	body := new(ActivateSyncInput)
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	m.Body = body
	return nil
}

func (m *ModelSyncActivateRequest) MarshalJSON() ([]byte, error) {
	return json.Marshal(m.Body)
}

type ModelSyncCancelRequest struct {
}

type CreateModelSyncRequest struct {
	// Whether the sync is enabled and scheduled.
	Active *bool `json:"active,omitempty" url:"active,omitempty"`
	// Passphrase for encrypting the sync data.
	EncryptionPassphrase *string `json:"encryption_passphrase,omitempty" url:"encryption_passphrase,omitempty"`
	// Fields to sync from source to destination.
	Fields []*ModelSyncField `json:"fields,omitempty" url:"fields,omitempty"`
	// Logical expression to combine filters.
	FilterLogic *string `json:"filter_logic,omitempty" url:"filter_logic,omitempty"`
	// Filters to apply to the source data.
	Filters  []*Filter     `json:"filters,omitempty" url:"filters,omitempty"`
	Identity *Identity     `json:"identity,omitempty" url:"identity,omitempty"`
	Mode     ModelSyncMode `json:"mode,omitempty" url:"mode,omitempty"`
	Name     string        `json:"name" url:"name"`
	// Whether to use enrichment models as a source of possible changes to sync. If true, only changes to the base models will cause a record to sync.
	OnlyEnrichUpdates *bool `json:"only_enrich_updates,omitempty" url:"only_enrich_updates,omitempty"`
	// Organization ID for the sync; read-only with a partner key.
	OrganizationID *string `json:"organization_id,omitempty" url:"organization_id,omitempty"`
	// Values to set in the target unconditionally.
	OverrideFields []*ModelSyncField `json:"override_fields,omitempty" url:"override_fields,omitempty"`
	// Conditional value replacement for fields.
	Overrides []*Override `json:"overrides,omitempty" url:"overrides,omitempty"`
	Policies  []string    `json:"policies,omitempty" url:"policies,omitempty"`
	Schedule  *Schedule   `json:"schedule,omitempty" url:"schedule,omitempty"`
	// Whether to skip the initial backfill of records; if true only records seen after the sync is enabled will be synced.
	SkipInitialBackfill *bool `json:"skip_initial_backfill,omitempty" url:"skip_initial_backfill,omitempty"`
	// Whether to sync all records from the source, regardless of whether they've changed since the previous execution.
	SyncAllRecords *bool   `json:"sync_all_records,omitempty" url:"sync_all_records,omitempty"`
	Target         *Target `json:"target,omitempty" url:"target,omitempty"`
}

type ModelSyncGetRequest struct {
}

type ModelSyncGetSourceRequest struct {
	Params map[string][]string `json:"-" url:"params,omitempty"`
}

type ModelSyncGetSourceFieldsRequest struct {
	Params map[string][]string `json:"-" url:"params,omitempty"`
}

type ModelSyncGetStatusRequest struct {
}

type ModelSyncListRequest struct {
	Active             *bool          `json:"-" url:"active,omitempty"`
	Mode               *ModelSyncMode `json:"-" url:"mode,omitempty"`
	TargetConnectionID *string        `json:"-" url:"target_connection_id,omitempty"`
}

type ModelSyncRemoveRequest struct {
}

type StartModelSyncRequest struct {
	Identities []string `json:"identities,omitempty" url:"identities,omitempty"`
	Resync     *bool    `json:"resync,omitempty" url:"resync,omitempty"`
	Test       *bool    `json:"test,omitempty" url:"test,omitempty"`
}

type UpdateModelSyncRequest struct {
	// Whether the sync is enabled and scheduled.
	Active *bool `json:"active,omitempty" url:"active,omitempty"`
	// Passphrase for encrypting the sync data.
	EncryptionPassphrase *string `json:"encryption_passphrase,omitempty" url:"encryption_passphrase,omitempty"`
	// Fields to sync from source to destination.
	Fields []*ModelSyncField `json:"fields,omitempty" url:"fields,omitempty"`
	// Logical expression to combine filters.
	FilterLogic *string `json:"filter_logic,omitempty" url:"filter_logic,omitempty"`
	// Filters to apply to the source data.
	Filters  []*Filter     `json:"filters,omitempty" url:"filters,omitempty"`
	Identity *Identity     `json:"identity,omitempty" url:"identity,omitempty"`
	Mode     ModelSyncMode `json:"mode,omitempty" url:"mode,omitempty"`
	Name     string        `json:"name" url:"name"`
	// Whether to use enrichment models as a source of possible changes to sync. If true, only changes to the base models will cause a record to sync.
	OnlyEnrichUpdates *bool `json:"only_enrich_updates,omitempty" url:"only_enrich_updates,omitempty"`
	// Organization ID for the sync; read-only with a partner key.
	OrganizationID *string `json:"organization_id,omitempty" url:"organization_id,omitempty"`
	// Values to set in the target unconditionally.
	OverrideFields []*ModelSyncField `json:"override_fields,omitempty" url:"override_fields,omitempty"`
	// Conditional value replacement for fields.
	Overrides []*Override `json:"overrides,omitempty" url:"overrides,omitempty"`
	Policies  []string    `json:"policies,omitempty" url:"policies,omitempty"`
	Schedule  *Schedule   `json:"schedule,omitempty" url:"schedule,omitempty"`
	// Whether to skip the initial backfill of records; if true only records seen after the sync is enabled will be synced.
	SkipInitialBackfill *bool `json:"skip_initial_backfill,omitempty" url:"skip_initial_backfill,omitempty"`
	// Whether to sync all records from the source, regardless of whether they've changed since the previous execution.
	SyncAllRecords *bool   `json:"sync_all_records,omitempty" url:"sync_all_records,omitempty"`
	Target         *Target `json:"target,omitempty" url:"target,omitempty"`
}

type CancelModelSyncResponse struct {
	Message *string `json:"message,omitempty" url:"message,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CancelModelSyncResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CancelModelSyncResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CancelModelSyncResponse(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CancelModelSyncResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CancelModelSyncResponseEnvelope struct {
	Data *CancelModelSyncResponse `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CancelModelSyncResponseEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler CancelModelSyncResponseEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CancelModelSyncResponseEnvelope(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CancelModelSyncResponseEnvelope) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Either `field` or `field_id` must be provided. If `field` is provided, `field_id` is ignored.
type Filter struct {
	Field *Source `json:"field,omitempty" url:"field,omitempty"`
	// Model or Target field name to filter on.
	FieldID   *string                   `json:"field_id,omitempty" url:"field_id,omitempty"`
	FieldType *FilterFieldReferenceType `json:"field_type,omitempty" url:"field_type,omitempty"`
	Function  FilterFunction            `json:"function,omitempty" url:"function,omitempty"`
	Label     *string                   `json:"label,omitempty" url:"label,omitempty"`
	Value     interface{}               `json:"value,omitempty" url:"value,omitempty"`

	_rawJSON json.RawMessage
}

func (f *Filter) UnmarshalJSON(data []byte) error {
	type unmarshaler Filter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = Filter(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *Filter) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FilterFieldReferenceType string

const (
	FilterFieldReferenceTypeModel  FilterFieldReferenceType = "Model"
	FilterFieldReferenceTypeTarget FilterFieldReferenceType = "Target"
)

func NewFilterFieldReferenceTypeFromString(s string) (FilterFieldReferenceType, error) {
	switch s {
	case "Model":
		return FilterFieldReferenceTypeModel, nil
	case "Target":
		return FilterFieldReferenceTypeTarget, nil
	}
	var t FilterFieldReferenceType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FilterFieldReferenceType) Ptr() *FilterFieldReferenceType {
	return &f
}

type Identity struct {
	Function          SchemaIdentityFunction `json:"function,omitempty" url:"function,omitempty"`
	NewField          *bool                  `json:"new_field,omitempty" url:"new_field,omitempty"`
	RemoteFieldTypeID *string                `json:"remote_field_type_id,omitempty" url:"remote_field_type_id,omitempty"`
	Source            *Source                `json:"source,omitempty" url:"source,omitempty"`
	Target            string                 `json:"target" url:"target"`

	_rawJSON json.RawMessage
}

func (i *Identity) UnmarshalJSON(data []byte) error {
	type unmarshaler Identity
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = Identity(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *Identity) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type JsonschemaForm = map[string]interface{}

type ListModelSyncResponseEnvelope struct {
	Data []*ModelSyncResponse `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (l *ListModelSyncResponseEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler ListModelSyncResponseEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListModelSyncResponseEnvelope(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListModelSyncResponseEnvelope) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ModelFieldResponse struct {
	Data []*ModelField `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (m *ModelFieldResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ModelFieldResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = ModelFieldResponse(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *ModelFieldResponse) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type ModelSyncField struct {
	// Whether the field should be encrypted.
	EncryptionEnabled *bool `json:"encryption_enabled,omitempty" url:"encryption_enabled,omitempty"`
	// New is set to true if the target field should be created by Polytomic. This is not supported by all backends.
	New *bool `json:"new,omitempty" url:"new,omitempty"`
	// Value to set in the target field; if provided, 'source' is ignored.
	OverrideValue *string `json:"override_value,omitempty" url:"override_value,omitempty"`
	Source        *Source `json:"source,omitempty" url:"source,omitempty"`
	// Sync mode for the field; defaults to 'updateOrCreate'. If set to 'create', the field will not be synced if it already has a value. This is not supported by all backends.
	SyncMode *string `json:"sync_mode,omitempty" url:"sync_mode,omitempty"`
	// Target field ID the source field value will be written to.
	Target string `json:"target" url:"target"`

	_rawJSON json.RawMessage
}

func (m *ModelSyncField) UnmarshalJSON(data []byte) error {
	type unmarshaler ModelSyncField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = ModelSyncField(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *ModelSyncField) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type ModelSyncResponse struct {
	Active               *bool              `json:"active,omitempty" url:"active,omitempty"`
	CreatedAt            *time.Time         `json:"created_at,omitempty" url:"created_at,omitempty"`
	CreatedBy            *CommonOutputActor `json:"created_by,omitempty" url:"created_by,omitempty"`
	EncryptionPassphrase *string            `json:"encryption_passphrase,omitempty" url:"encryption_passphrase,omitempty"`
	Fields               []*ModelSyncField  `json:"fields,omitempty" url:"fields,omitempty"`
	FilterLogic          *string            `json:"filter_logic,omitempty" url:"filter_logic,omitempty"`
	Filters              []*Filter          `json:"filters,omitempty" url:"filters,omitempty"`
	ID                   *string            `json:"id,omitempty" url:"id,omitempty"`
	Identity             *Identity          `json:"identity,omitempty" url:"identity,omitempty"`
	Mode                 *ModelSyncMode     `json:"mode,omitempty" url:"mode,omitempty"`
	// Model IDs used in the sync.
	ModelIDs            []string           `json:"model_ids,omitempty" url:"model_ids,omitempty"`
	Name                *string            `json:"name,omitempty" url:"name,omitempty"`
	OnlyEnrichUpdates   *bool              `json:"only_enrich_updates,omitempty" url:"only_enrich_updates,omitempty"`
	OrganizationID      *string            `json:"organization_id,omitempty" url:"organization_id,omitempty"`
	OverrideFields      []*ModelSyncField  `json:"override_fields,omitempty" url:"override_fields,omitempty"`
	Overrides           []*Override        `json:"overrides,omitempty" url:"overrides,omitempty"`
	Policies            []string           `json:"policies,omitempty" url:"policies,omitempty"`
	Schedule            *Schedule          `json:"schedule,omitempty" url:"schedule,omitempty"`
	SkipInitialBackfill *bool              `json:"skip_initial_backfill,omitempty" url:"skip_initial_backfill,omitempty"`
	SyncAllRecords      *bool              `json:"sync_all_records,omitempty" url:"sync_all_records,omitempty"`
	Target              *Target            `json:"target,omitempty" url:"target,omitempty"`
	UpdatedAt           *time.Time         `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	UpdatedBy           *CommonOutputActor `json:"updated_by,omitempty" url:"updated_by,omitempty"`

	_rawJSON json.RawMessage
}

func (m *ModelSyncResponse) UnmarshalJSON(data []byte) error {
	type embed ModelSyncResponse
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at,omitempty"`
		UpdatedAt *core.DateTime `json:"updated_at,omitempty"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = ModelSyncResponse(unmarshaler.embed)
	m.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	m.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *ModelSyncResponse) MarshalJSON() ([]byte, error) {
	type embed ModelSyncResponse
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at,omitempty"`
		UpdatedAt *core.DateTime `json:"updated_at,omitempty"`
	}{
		embed:     embed(*m),
		CreatedAt: core.NewOptionalDateTime(m.CreatedAt),
		UpdatedAt: core.NewOptionalDateTime(m.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (m *ModelSyncResponse) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type ModelSyncResponseEnvelope struct {
	Data *ModelSyncResponse `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (m *ModelSyncResponseEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler ModelSyncResponseEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = ModelSyncResponseEnvelope(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *ModelSyncResponseEnvelope) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// Either `field` or `field_id` must be provided. If `field_id` is provided, `field` is ignored.
type Override struct {
	Field *Source `json:"field,omitempty" url:"field,omitempty"`
	// Field ID of the model field to override.
	FieldID  *string         `json:"field_id,omitempty" url:"field_id,omitempty"`
	Function *FilterFunction `json:"function,omitempty" url:"function,omitempty"`
	Override interface{}     `json:"override,omitempty" url:"override,omitempty"`
	Value    interface{}     `json:"value,omitempty" url:"value,omitempty"`

	_rawJSON json.RawMessage
}

func (o *Override) UnmarshalJSON(data []byte) error {
	type unmarshaler Override
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = Override(value)
	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *Override) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type RunAfter struct {
	BulkSyncIDs []string `json:"bulk_sync_ids,omitempty" url:"bulk_sync_ids,omitempty"`
	SyncIDs     []string `json:"sync_ids,omitempty" url:"sync_ids,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RunAfter) UnmarshalJSON(data []byte) error {
	type unmarshaler RunAfter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RunAfter(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RunAfter) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type Schedule struct {
	ConnectionID *string            `json:"connection_id,omitempty" url:"connection_id,omitempty"`
	DayOfMonth   *string            `json:"day_of_month,omitempty" url:"day_of_month,omitempty"`
	DayOfWeek    *string            `json:"day_of_week,omitempty" url:"day_of_week,omitempty"`
	Frequency    *ScheduleFrequency `json:"frequency,omitempty" url:"frequency,omitempty"`
	Hour         *string            `json:"hour,omitempty" url:"hour,omitempty"`
	JobID        *int               `json:"job_id,omitempty" url:"job_id,omitempty"`
	Minute       *string            `json:"minute,omitempty" url:"minute,omitempty"`
	Month        *string            `json:"month,omitempty" url:"month,omitempty"`
	RunAfter     *RunAfter          `json:"run_after,omitempty" url:"run_after,omitempty"`
	// If true, the sync will only run if the dependent syncs completed successfully.
	RunAfterSuccessOnly *bool `json:"run_after_success_only,omitempty" url:"run_after_success_only,omitempty"`

	_rawJSON json.RawMessage
}

func (s *Schedule) UnmarshalJSON(data []byte) error {
	type unmarshaler Schedule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Schedule(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *Schedule) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ScheduleOptionResponse struct {
	ScheduleOptions []*ScheduleScheduleOption `json:"schedule_options,omitempty" url:"schedule_options,omitempty"`

	_rawJSON json.RawMessage
}

func (s *ScheduleOptionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ScheduleOptionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ScheduleOptionResponse(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ScheduleOptionResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ScheduleOptionResponseEnvelope struct {
	Data *ScheduleOptionResponse `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (s *ScheduleOptionResponseEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler ScheduleOptionResponseEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ScheduleOptionResponseEnvelope(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ScheduleOptionResponseEnvelope) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ScheduleScheduleOption struct {
	Configuration *JsonschemaForm    `json:"configuration,omitempty" url:"configuration,omitempty"`
	Description   *string            `json:"description,omitempty" url:"description,omitempty"`
	Frequency     *ScheduleFrequency `json:"frequency,omitempty" url:"frequency,omitempty"`
	Label         *string            `json:"label,omitempty" url:"label,omitempty"`

	_rawJSON json.RawMessage
}

func (s *ScheduleScheduleOption) UnmarshalJSON(data []byte) error {
	type unmarshaler ScheduleScheduleOption
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ScheduleScheduleOption(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ScheduleScheduleOption) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SchemaIdentityFunction string

const (
	SchemaIdentityFunctionEquality      SchemaIdentityFunction = "Equality"
	SchemaIdentityFunctionISubstring    SchemaIdentityFunction = "ISubstring"
	SchemaIdentityFunctionOneOf         SchemaIdentityFunction = "OneOf"
	SchemaIdentityFunctionDomainMatch   SchemaIdentityFunction = "DomainMatch"
	SchemaIdentityFunctionHostnameMatch SchemaIdentityFunction = "HostnameMatch"
)

func NewSchemaIdentityFunctionFromString(s string) (SchemaIdentityFunction, error) {
	switch s {
	case "Equality":
		return SchemaIdentityFunctionEquality, nil
	case "ISubstring":
		return SchemaIdentityFunctionISubstring, nil
	case "OneOf":
		return SchemaIdentityFunctionOneOf, nil
	case "DomainMatch":
		return SchemaIdentityFunctionDomainMatch, nil
	case "HostnameMatch":
		return SchemaIdentityFunctionHostnameMatch, nil
	}
	var t SchemaIdentityFunction
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SchemaIdentityFunction) Ptr() *SchemaIdentityFunction {
	return &s
}

type Source struct {
	Field   string `json:"field" url:"field"`
	ModelID string `json:"model_id" url:"model_id"`

	_rawJSON json.RawMessage
}

func (s *Source) UnmarshalJSON(data []byte) error {
	type unmarshaler Source
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Source(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *Source) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type StartModelSyncResponseEnvelope struct {
	Data *StartModelSyncResponseSchema `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (s *StartModelSyncResponseEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler StartModelSyncResponseEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StartModelSyncResponseEnvelope(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *StartModelSyncResponseEnvelope) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type StartModelSyncResponseSchema struct {
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Execution ID
	ID     *string          `json:"id,omitempty" url:"id,omitempty"`
	Status *ExecutionStatus `json:"status,omitempty" url:"status,omitempty"`

	_rawJSON json.RawMessage
}

func (s *StartModelSyncResponseSchema) UnmarshalJSON(data []byte) error {
	type embed StartModelSyncResponseSchema
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = StartModelSyncResponseSchema(unmarshaler.embed)
	s.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *StartModelSyncResponseSchema) MarshalJSON() ([]byte, error) {
	type embed StartModelSyncResponseSchema
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at,omitempty"`
	}{
		embed:     embed(*s),
		CreatedAt: core.NewOptionalDateTime(s.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (s *StartModelSyncResponseSchema) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SyncStatusEnvelope struct {
	Data *SyncStatusResponse `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SyncStatusEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler SyncStatusEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SyncStatusEnvelope(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SyncStatusEnvelope) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SyncStatusResponse struct {
	CurrentExecution  *GetExecutionResponseSchema `json:"current_execution,omitempty" url:"current_execution,omitempty"`
	LastExecution     *GetExecutionResponseSchema `json:"last_execution,omitempty" url:"last_execution,omitempty"`
	NextExecutionTime *time.Time                  `json:"next_execution_time,omitempty" url:"next_execution_time,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SyncStatusResponse) UnmarshalJSON(data []byte) error {
	type embed SyncStatusResponse
	var unmarshaler = struct {
		embed
		NextExecutionTime *core.DateTime `json:"next_execution_time,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SyncStatusResponse(unmarshaler.embed)
	s.NextExecutionTime = unmarshaler.NextExecutionTime.TimePtr()
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SyncStatusResponse) MarshalJSON() ([]byte, error) {
	type embed SyncStatusResponse
	var marshaler = struct {
		embed
		NextExecutionTime *core.DateTime `json:"next_execution_time,omitempty"`
	}{
		embed:             embed(*s),
		NextExecutionTime: core.NewOptionalDateTime(s.NextExecutionTime),
	}
	return json.Marshal(marshaler)
}

func (s *SyncStatusResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type Target struct {
	Configuration map[string]interface{} `json:"configuration,omitempty" url:"configuration,omitempty"`
	ConnectionID  string                 `json:"connection_id" url:"connection_id"`
	// Create a new target object with these properties.
	Create      map[string]string `json:"create,omitempty" url:"create,omitempty"`
	FilterLogic *string           `json:"filter_logic,omitempty" url:"filter_logic,omitempty"`
	// Name for a new target object.
	NewName      *string                `json:"new_name,omitempty" url:"new_name,omitempty"`
	Object       *string                `json:"object,omitempty" url:"object,omitempty"`
	SearchValues map[string]interface{} `json:"search_values,omitempty" url:"search_values,omitempty"`

	_rawJSON json.RawMessage
}

func (t *Target) UnmarshalJSON(data []byte) error {
	type unmarshaler Target
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Target(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *Target) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}
