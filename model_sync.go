// This file was auto-generated by Fern from our API Definition.

package polytomic

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/polytomic/polytomic-go/internal"
	time "time"
)

type ModelSyncActivateRequest struct {
	Body *ActivateSyncInput `json:"-" url:"-"`
}

func (m *ModelSyncActivateRequest) UnmarshalJSON(data []byte) error {
	body := new(ActivateSyncInput)
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	m.Body = body
	return nil
}

func (m *ModelSyncActivateRequest) MarshalJSON() ([]byte, error) {
	return json.Marshal(m.Body)
}

type CreateModelSyncRequest struct {
	// Whether the sync is enabled and scheduled.
	Active *bool `json:"active,omitempty" url:"-"`
	// Passphrase for encrypting the sync data.
	EncryptionPassphrase *string `json:"encryption_passphrase,omitempty" url:"-"`
	// Fields to sync from source to destination.
	Fields []*ModelSyncField `json:"fields,omitempty" url:"-"`
	// Logical expression to combine filters.
	FilterLogic *string `json:"filter_logic,omitempty" url:"-"`
	// Filters to apply to the source data.
	Filters  []*Filter     `json:"filters,omitempty" url:"-"`
	Identity *Identity     `json:"identity,omitempty" url:"-"`
	Mode     ModelSyncMode `json:"mode" url:"-"`
	Name     string        `json:"name" url:"-"`
	// Whether to use enrichment models as a source of possible changes to sync. If true, only changes to the base models will cause a record to sync.
	OnlyEnrichUpdates *bool `json:"only_enrich_updates,omitempty" url:"-"`
	// Organization ID for the sync; read-only with a partner key.
	OrganizationId *string `json:"organization_id,omitempty" url:"-"`
	// Values to set in the target unconditionally.
	OverrideFields []*ModelSyncField `json:"override_fields,omitempty" url:"-"`
	// Conditional value replacement for fields.
	Overrides []*Override `json:"overrides,omitempty" url:"-"`
	Policies  []string    `json:"policies,omitempty" url:"-"`
	Schedule  *Schedule   `json:"schedule,omitempty" url:"-"`
	// Whether to skip the initial backfill of records; if true only records seen after the sync is enabled will be synced.
	SkipInitialBackfill *bool `json:"skip_initial_backfill,omitempty" url:"-"`
	// Whether to sync all records from the source, regardless of whether they've changed since the previous execution.
	SyncAllRecords *bool   `json:"sync_all_records,omitempty" url:"-"`
	Target         *Target `json:"target,omitempty" url:"-"`
}

type ModelSyncGetSourceRequest struct {
	Params map[string][]string `json:"-" url:"params,omitempty"`
}

type ModelSyncGetSourceFieldsRequest struct {
	Params map[string][]string `json:"-" url:"params,omitempty"`
}

type ModelSyncListRequest struct {
	Active             *bool          `json:"-" url:"active,omitempty"`
	Mode               *ModelSyncMode `json:"-" url:"mode,omitempty"`
	TargetConnectionId *string        `json:"-" url:"target_connection_id,omitempty"`
}

type StartModelSyncRequest struct {
	Identities []string `json:"identities,omitempty" url:"-"`
	Resync     *bool    `json:"resync,omitempty" url:"-"`
	Test       *bool    `json:"test,omitempty" url:"-"`
}

type UpdateModelSyncRequest struct {
	// Whether the sync is enabled and scheduled.
	Active *bool `json:"active,omitempty" url:"-"`
	// Passphrase for encrypting the sync data.
	EncryptionPassphrase *string `json:"encryption_passphrase,omitempty" url:"-"`
	// Fields to sync from source to destination.
	Fields []*ModelSyncField `json:"fields,omitempty" url:"-"`
	// Logical expression to combine filters.
	FilterLogic *string `json:"filter_logic,omitempty" url:"-"`
	// Filters to apply to the source data.
	Filters  []*Filter     `json:"filters,omitempty" url:"-"`
	Identity *Identity     `json:"identity,omitempty" url:"-"`
	Mode     ModelSyncMode `json:"mode" url:"-"`
	Name     string        `json:"name" url:"-"`
	// Whether to use enrichment models as a source of possible changes to sync. If true, only changes to the base models will cause a record to sync.
	OnlyEnrichUpdates *bool `json:"only_enrich_updates,omitempty" url:"-"`
	// Organization ID for the sync; read-only with a partner key.
	OrganizationId *string `json:"organization_id,omitempty" url:"-"`
	// Values to set in the target unconditionally.
	OverrideFields []*ModelSyncField `json:"override_fields,omitempty" url:"-"`
	// Conditional value replacement for fields.
	Overrides []*Override `json:"overrides,omitempty" url:"-"`
	Policies  []string    `json:"policies,omitempty" url:"-"`
	Schedule  *Schedule   `json:"schedule,omitempty" url:"-"`
	// Whether to skip the initial backfill of records; if true only records seen after the sync is enabled will be synced.
	SkipInitialBackfill *bool `json:"skip_initial_backfill,omitempty" url:"-"`
	// Whether to sync all records from the source, regardless of whether they've changed since the previous execution.
	SyncAllRecords *bool   `json:"sync_all_records,omitempty" url:"-"`
	Target         *Target `json:"target,omitempty" url:"-"`
}

type CancelModelSyncResponse struct {
	Message *string `json:"message,omitempty" url:"message,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CancelModelSyncResponse) GetMessage() *string {
	if c == nil {
		return nil
	}
	return c.Message
}

func (c *CancelModelSyncResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CancelModelSyncResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CancelModelSyncResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CancelModelSyncResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CancelModelSyncResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CancelModelSyncResponseEnvelope struct {
	Data *CancelModelSyncResponse `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CancelModelSyncResponseEnvelope) GetData() *CancelModelSyncResponse {
	if c == nil {
		return nil
	}
	return c.Data
}

func (c *CancelModelSyncResponseEnvelope) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CancelModelSyncResponseEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler CancelModelSyncResponseEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CancelModelSyncResponseEnvelope(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CancelModelSyncResponseEnvelope) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Either `field` or `field_id` must be provided. If `field` is provided, `field_id` is ignored.
type Filter struct {
	Field *Source `json:"field,omitempty" url:"field,omitempty"`
	// Model or Target field name to filter on.
	FieldId   *string                   `json:"field_id,omitempty" url:"field_id,omitempty"`
	FieldType *FilterFieldReferenceType `json:"field_type,omitempty" url:"field_type,omitempty"`
	Function  FilterFunction            `json:"function" url:"function"`
	Label     *string                   `json:"label,omitempty" url:"label,omitempty"`
	Value     interface{}               `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *Filter) GetField() *Source {
	if f == nil {
		return nil
	}
	return f.Field
}

func (f *Filter) GetFieldId() *string {
	if f == nil {
		return nil
	}
	return f.FieldId
}

func (f *Filter) GetFieldType() *FilterFieldReferenceType {
	if f == nil {
		return nil
	}
	return f.FieldType
}

func (f *Filter) GetFunction() FilterFunction {
	if f == nil {
		return ""
	}
	return f.Function
}

func (f *Filter) GetLabel() *string {
	if f == nil {
		return nil
	}
	return f.Label
}

func (f *Filter) GetValue() interface{} {
	if f == nil {
		return nil
	}
	return f.Value
}

func (f *Filter) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *Filter) UnmarshalJSON(data []byte) error {
	type unmarshaler Filter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = Filter(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *Filter) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FilterFieldReferenceType string

const (
	FilterFieldReferenceTypeModel  FilterFieldReferenceType = "Model"
	FilterFieldReferenceTypeTarget FilterFieldReferenceType = "Target"
)

func NewFilterFieldReferenceTypeFromString(s string) (FilterFieldReferenceType, error) {
	switch s {
	case "Model":
		return FilterFieldReferenceTypeModel, nil
	case "Target":
		return FilterFieldReferenceTypeTarget, nil
	}
	var t FilterFieldReferenceType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FilterFieldReferenceType) Ptr() *FilterFieldReferenceType {
	return &f
}

type Identity struct {
	Function          SchemaIdentityFunction `json:"function" url:"function"`
	NewField          *bool                  `json:"new_field,omitempty" url:"new_field,omitempty"`
	RemoteFieldTypeId *string                `json:"remote_field_type_id,omitempty" url:"remote_field_type_id,omitempty"`
	Source            *Source                `json:"source,omitempty" url:"source,omitempty"`
	Target            string                 `json:"target" url:"target"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *Identity) GetFunction() SchemaIdentityFunction {
	if i == nil {
		return ""
	}
	return i.Function
}

func (i *Identity) GetNewField() *bool {
	if i == nil {
		return nil
	}
	return i.NewField
}

func (i *Identity) GetRemoteFieldTypeId() *string {
	if i == nil {
		return nil
	}
	return i.RemoteFieldTypeId
}

func (i *Identity) GetSource() *Source {
	if i == nil {
		return nil
	}
	return i.Source
}

func (i *Identity) GetTarget() string {
	if i == nil {
		return ""
	}
	return i.Target
}

func (i *Identity) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *Identity) UnmarshalJSON(data []byte) error {
	type unmarshaler Identity
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = Identity(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *Identity) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type JsonschemaForm = map[string]interface{}

type ListModelSyncResponseEnvelope struct {
	Data []*ModelSyncResponse `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListModelSyncResponseEnvelope) GetData() []*ModelSyncResponse {
	if l == nil {
		return nil
	}
	return l.Data
}

func (l *ListModelSyncResponseEnvelope) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListModelSyncResponseEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler ListModelSyncResponseEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListModelSyncResponseEnvelope(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListModelSyncResponseEnvelope) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ModelFieldResponse struct {
	Data []*ModelField `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *ModelFieldResponse) GetData() []*ModelField {
	if m == nil {
		return nil
	}
	return m.Data
}

func (m *ModelFieldResponse) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *ModelFieldResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ModelFieldResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = ModelFieldResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *ModelFieldResponse) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type ModelSyncField struct {
	// Whether the field should be encrypted.
	EncryptionEnabled *bool `json:"encryption_enabled,omitempty" url:"encryption_enabled,omitempty"`
	// New is set to true if the target field should be created by Polytomic. This is not supported by all backends.
	New *bool `json:"new,omitempty" url:"new,omitempty"`
	// Value to set in the target field; if provided, 'source' is ignored.
	OverrideValue *string `json:"override_value,omitempty" url:"override_value,omitempty"`
	Source        *Source `json:"source,omitempty" url:"source,omitempty"`
	// Sync mode for the field; defaults to 'updateOrCreate'. If set to 'create', the field will not be synced if it already has a value. This is not supported by all backends.
	SyncMode *string `json:"sync_mode,omitempty" url:"sync_mode,omitempty"`
	// Target field ID the source field value will be written to.
	Target string `json:"target" url:"target"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *ModelSyncField) GetEncryptionEnabled() *bool {
	if m == nil {
		return nil
	}
	return m.EncryptionEnabled
}

func (m *ModelSyncField) GetNew() *bool {
	if m == nil {
		return nil
	}
	return m.New
}

func (m *ModelSyncField) GetOverrideValue() *string {
	if m == nil {
		return nil
	}
	return m.OverrideValue
}

func (m *ModelSyncField) GetSource() *Source {
	if m == nil {
		return nil
	}
	return m.Source
}

func (m *ModelSyncField) GetSyncMode() *string {
	if m == nil {
		return nil
	}
	return m.SyncMode
}

func (m *ModelSyncField) GetTarget() string {
	if m == nil {
		return ""
	}
	return m.Target
}

func (m *ModelSyncField) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *ModelSyncField) UnmarshalJSON(data []byte) error {
	type unmarshaler ModelSyncField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = ModelSyncField(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *ModelSyncField) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type ModelSyncResponse struct {
	Active               *bool              `json:"active,omitempty" url:"active,omitempty"`
	CreatedAt            *time.Time         `json:"created_at,omitempty" url:"created_at,omitempty"`
	CreatedBy            *CommonOutputActor `json:"created_by,omitempty" url:"created_by,omitempty"`
	EncryptionPassphrase *string            `json:"encryption_passphrase,omitempty" url:"encryption_passphrase,omitempty"`
	Fields               []*ModelSyncField  `json:"fields,omitempty" url:"fields,omitempty"`
	FilterLogic          *string            `json:"filter_logic,omitempty" url:"filter_logic,omitempty"`
	Filters              []*Filter          `json:"filters,omitempty" url:"filters,omitempty"`
	Id                   *string            `json:"id,omitempty" url:"id,omitempty"`
	Identity             *Identity          `json:"identity,omitempty" url:"identity,omitempty"`
	Mode                 *ModelSyncMode     `json:"mode,omitempty" url:"mode,omitempty"`
	// Model IDs used in the sync.
	ModelIds            []string           `json:"model_ids,omitempty" url:"model_ids,omitempty"`
	Name                *string            `json:"name,omitempty" url:"name,omitempty"`
	OnlyEnrichUpdates   *bool              `json:"only_enrich_updates,omitempty" url:"only_enrich_updates,omitempty"`
	OrganizationId      *string            `json:"organization_id,omitempty" url:"organization_id,omitempty"`
	OverrideFields      []*ModelSyncField  `json:"override_fields,omitempty" url:"override_fields,omitempty"`
	Overrides           []*Override        `json:"overrides,omitempty" url:"overrides,omitempty"`
	Policies            []string           `json:"policies,omitempty" url:"policies,omitempty"`
	Schedule            *Schedule          `json:"schedule,omitempty" url:"schedule,omitempty"`
	SkipInitialBackfill *bool              `json:"skip_initial_backfill,omitempty" url:"skip_initial_backfill,omitempty"`
	SyncAllRecords      *bool              `json:"sync_all_records,omitempty" url:"sync_all_records,omitempty"`
	Target              *Target            `json:"target,omitempty" url:"target,omitempty"`
	UpdatedAt           *time.Time         `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	UpdatedBy           *CommonOutputActor `json:"updated_by,omitempty" url:"updated_by,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *ModelSyncResponse) GetActive() *bool {
	if m == nil {
		return nil
	}
	return m.Active
}

func (m *ModelSyncResponse) GetCreatedAt() *time.Time {
	if m == nil {
		return nil
	}
	return m.CreatedAt
}

func (m *ModelSyncResponse) GetCreatedBy() *CommonOutputActor {
	if m == nil {
		return nil
	}
	return m.CreatedBy
}

func (m *ModelSyncResponse) GetEncryptionPassphrase() *string {
	if m == nil {
		return nil
	}
	return m.EncryptionPassphrase
}

func (m *ModelSyncResponse) GetFields() []*ModelSyncField {
	if m == nil {
		return nil
	}
	return m.Fields
}

func (m *ModelSyncResponse) GetFilterLogic() *string {
	if m == nil {
		return nil
	}
	return m.FilterLogic
}

func (m *ModelSyncResponse) GetFilters() []*Filter {
	if m == nil {
		return nil
	}
	return m.Filters
}

func (m *ModelSyncResponse) GetId() *string {
	if m == nil {
		return nil
	}
	return m.Id
}

func (m *ModelSyncResponse) GetIdentity() *Identity {
	if m == nil {
		return nil
	}
	return m.Identity
}

func (m *ModelSyncResponse) GetMode() *ModelSyncMode {
	if m == nil {
		return nil
	}
	return m.Mode
}

func (m *ModelSyncResponse) GetModelIds() []string {
	if m == nil {
		return nil
	}
	return m.ModelIds
}

func (m *ModelSyncResponse) GetName() *string {
	if m == nil {
		return nil
	}
	return m.Name
}

func (m *ModelSyncResponse) GetOnlyEnrichUpdates() *bool {
	if m == nil {
		return nil
	}
	return m.OnlyEnrichUpdates
}

func (m *ModelSyncResponse) GetOrganizationId() *string {
	if m == nil {
		return nil
	}
	return m.OrganizationId
}

func (m *ModelSyncResponse) GetOverrideFields() []*ModelSyncField {
	if m == nil {
		return nil
	}
	return m.OverrideFields
}

func (m *ModelSyncResponse) GetOverrides() []*Override {
	if m == nil {
		return nil
	}
	return m.Overrides
}

func (m *ModelSyncResponse) GetPolicies() []string {
	if m == nil {
		return nil
	}
	return m.Policies
}

func (m *ModelSyncResponse) GetSchedule() *Schedule {
	if m == nil {
		return nil
	}
	return m.Schedule
}

func (m *ModelSyncResponse) GetSkipInitialBackfill() *bool {
	if m == nil {
		return nil
	}
	return m.SkipInitialBackfill
}

func (m *ModelSyncResponse) GetSyncAllRecords() *bool {
	if m == nil {
		return nil
	}
	return m.SyncAllRecords
}

func (m *ModelSyncResponse) GetTarget() *Target {
	if m == nil {
		return nil
	}
	return m.Target
}

func (m *ModelSyncResponse) GetUpdatedAt() *time.Time {
	if m == nil {
		return nil
	}
	return m.UpdatedAt
}

func (m *ModelSyncResponse) GetUpdatedBy() *CommonOutputActor {
	if m == nil {
		return nil
	}
	return m.UpdatedBy
}

func (m *ModelSyncResponse) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *ModelSyncResponse) UnmarshalJSON(data []byte) error {
	type embed ModelSyncResponse
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"created_at,omitempty"`
		UpdatedAt *internal.DateTime `json:"updated_at,omitempty"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = ModelSyncResponse(unmarshaler.embed)
	m.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	m.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *ModelSyncResponse) MarshalJSON() ([]byte, error) {
	type embed ModelSyncResponse
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"created_at,omitempty"`
		UpdatedAt *internal.DateTime `json:"updated_at,omitempty"`
	}{
		embed:     embed(*m),
		CreatedAt: internal.NewOptionalDateTime(m.CreatedAt),
		UpdatedAt: internal.NewOptionalDateTime(m.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (m *ModelSyncResponse) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type ModelSyncResponseEnvelope struct {
	Data *ModelSyncResponse `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *ModelSyncResponseEnvelope) GetData() *ModelSyncResponse {
	if m == nil {
		return nil
	}
	return m.Data
}

func (m *ModelSyncResponseEnvelope) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *ModelSyncResponseEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler ModelSyncResponseEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = ModelSyncResponseEnvelope(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *ModelSyncResponseEnvelope) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// Either `field` or `field_id` must be provided. If `field_id` is provided, `field` is ignored.
type Override struct {
	Field *Source `json:"field,omitempty" url:"field,omitempty"`
	// Field ID of the model field to override.
	FieldId  *string         `json:"field_id,omitempty" url:"field_id,omitempty"`
	Function *FilterFunction `json:"function,omitempty" url:"function,omitempty"`
	Override interface{}     `json:"override,omitempty" url:"override,omitempty"`
	Value    interface{}     `json:"value,omitempty" url:"value,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *Override) GetField() *Source {
	if o == nil {
		return nil
	}
	return o.Field
}

func (o *Override) GetFieldId() *string {
	if o == nil {
		return nil
	}
	return o.FieldId
}

func (o *Override) GetFunction() *FilterFunction {
	if o == nil {
		return nil
	}
	return o.Function
}

func (o *Override) GetOverride() interface{} {
	if o == nil {
		return nil
	}
	return o.Override
}

func (o *Override) GetValue() interface{} {
	if o == nil {
		return nil
	}
	return o.Value
}

func (o *Override) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *Override) UnmarshalJSON(data []byte) error {
	type unmarshaler Override
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = Override(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *Override) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type RunAfter struct {
	BulkSyncIds []string `json:"bulk_sync_ids,omitempty" url:"bulk_sync_ids,omitempty"`
	SyncIds     []string `json:"sync_ids,omitempty" url:"sync_ids,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RunAfter) GetBulkSyncIds() []string {
	if r == nil {
		return nil
	}
	return r.BulkSyncIds
}

func (r *RunAfter) GetSyncIds() []string {
	if r == nil {
		return nil
	}
	return r.SyncIds
}

func (r *RunAfter) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RunAfter) UnmarshalJSON(data []byte) error {
	type unmarshaler RunAfter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RunAfter(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RunAfter) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type Schedule struct {
	ConnectionId *string            `json:"connection_id,omitempty" url:"connection_id,omitempty"`
	DayOfMonth   *string            `json:"day_of_month,omitempty" url:"day_of_month,omitempty"`
	DayOfWeek    *string            `json:"day_of_week,omitempty" url:"day_of_week,omitempty"`
	Frequency    *ScheduleFrequency `json:"frequency,omitempty" url:"frequency,omitempty"`
	Hour         *string            `json:"hour,omitempty" url:"hour,omitempty"`
	JobId        *int               `json:"job_id,omitempty" url:"job_id,omitempty"`
	Minute       *string            `json:"minute,omitempty" url:"minute,omitempty"`
	Month        *string            `json:"month,omitempty" url:"month,omitempty"`
	RunAfter     *RunAfter          `json:"run_after,omitempty" url:"run_after,omitempty"`
	// If true, the sync will only run if the dependent syncs completed successfully.
	RunAfterSuccessOnly *bool `json:"run_after_success_only,omitempty" url:"run_after_success_only,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *Schedule) GetConnectionId() *string {
	if s == nil {
		return nil
	}
	return s.ConnectionId
}

func (s *Schedule) GetDayOfMonth() *string {
	if s == nil {
		return nil
	}
	return s.DayOfMonth
}

func (s *Schedule) GetDayOfWeek() *string {
	if s == nil {
		return nil
	}
	return s.DayOfWeek
}

func (s *Schedule) GetFrequency() *ScheduleFrequency {
	if s == nil {
		return nil
	}
	return s.Frequency
}

func (s *Schedule) GetHour() *string {
	if s == nil {
		return nil
	}
	return s.Hour
}

func (s *Schedule) GetJobId() *int {
	if s == nil {
		return nil
	}
	return s.JobId
}

func (s *Schedule) GetMinute() *string {
	if s == nil {
		return nil
	}
	return s.Minute
}

func (s *Schedule) GetMonth() *string {
	if s == nil {
		return nil
	}
	return s.Month
}

func (s *Schedule) GetRunAfter() *RunAfter {
	if s == nil {
		return nil
	}
	return s.RunAfter
}

func (s *Schedule) GetRunAfterSuccessOnly() *bool {
	if s == nil {
		return nil
	}
	return s.RunAfterSuccessOnly
}

func (s *Schedule) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Schedule) UnmarshalJSON(data []byte) error {
	type unmarshaler Schedule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Schedule(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *Schedule) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ScheduleOptionResponse struct {
	ScheduleOptions []*ScheduleScheduleOption `json:"schedule_options,omitempty" url:"schedule_options,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ScheduleOptionResponse) GetScheduleOptions() []*ScheduleScheduleOption {
	if s == nil {
		return nil
	}
	return s.ScheduleOptions
}

func (s *ScheduleOptionResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ScheduleOptionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ScheduleOptionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ScheduleOptionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ScheduleOptionResponse) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ScheduleOptionResponseEnvelope struct {
	Data *ScheduleOptionResponse `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ScheduleOptionResponseEnvelope) GetData() *ScheduleOptionResponse {
	if s == nil {
		return nil
	}
	return s.Data
}

func (s *ScheduleOptionResponseEnvelope) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ScheduleOptionResponseEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler ScheduleOptionResponseEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ScheduleOptionResponseEnvelope(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ScheduleOptionResponseEnvelope) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ScheduleScheduleOption struct {
	Configuration *JsonschemaForm    `json:"configuration,omitempty" url:"configuration,omitempty"`
	Description   *string            `json:"description,omitempty" url:"description,omitempty"`
	Frequency     *ScheduleFrequency `json:"frequency,omitempty" url:"frequency,omitempty"`
	Label         *string            `json:"label,omitempty" url:"label,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ScheduleScheduleOption) GetConfiguration() *JsonschemaForm {
	if s == nil {
		return nil
	}
	return s.Configuration
}

func (s *ScheduleScheduleOption) GetDescription() *string {
	if s == nil {
		return nil
	}
	return s.Description
}

func (s *ScheduleScheduleOption) GetFrequency() *ScheduleFrequency {
	if s == nil {
		return nil
	}
	return s.Frequency
}

func (s *ScheduleScheduleOption) GetLabel() *string {
	if s == nil {
		return nil
	}
	return s.Label
}

func (s *ScheduleScheduleOption) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ScheduleScheduleOption) UnmarshalJSON(data []byte) error {
	type unmarshaler ScheduleScheduleOption
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ScheduleScheduleOption(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ScheduleScheduleOption) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SchemaIdentityFunction string

const (
	SchemaIdentityFunctionEquality      SchemaIdentityFunction = "Equality"
	SchemaIdentityFunctionISubstring    SchemaIdentityFunction = "ISubstring"
	SchemaIdentityFunctionOneOf         SchemaIdentityFunction = "OneOf"
	SchemaIdentityFunctionDomainMatch   SchemaIdentityFunction = "DomainMatch"
	SchemaIdentityFunctionHostnameMatch SchemaIdentityFunction = "HostnameMatch"
)

func NewSchemaIdentityFunctionFromString(s string) (SchemaIdentityFunction, error) {
	switch s {
	case "Equality":
		return SchemaIdentityFunctionEquality, nil
	case "ISubstring":
		return SchemaIdentityFunctionISubstring, nil
	case "OneOf":
		return SchemaIdentityFunctionOneOf, nil
	case "DomainMatch":
		return SchemaIdentityFunctionDomainMatch, nil
	case "HostnameMatch":
		return SchemaIdentityFunctionHostnameMatch, nil
	}
	var t SchemaIdentityFunction
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SchemaIdentityFunction) Ptr() *SchemaIdentityFunction {
	return &s
}

type Source struct {
	Field   string `json:"field" url:"field"`
	ModelId string `json:"model_id" url:"model_id"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *Source) GetField() string {
	if s == nil {
		return ""
	}
	return s.Field
}

func (s *Source) GetModelId() string {
	if s == nil {
		return ""
	}
	return s.ModelId
}

func (s *Source) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Source) UnmarshalJSON(data []byte) error {
	type unmarshaler Source
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Source(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *Source) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type StartModelSyncResponseEnvelope struct {
	Data *StartModelSyncResponseSchema `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *StartModelSyncResponseEnvelope) GetData() *StartModelSyncResponseSchema {
	if s == nil {
		return nil
	}
	return s.Data
}

func (s *StartModelSyncResponseEnvelope) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StartModelSyncResponseEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler StartModelSyncResponseEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StartModelSyncResponseEnvelope(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *StartModelSyncResponseEnvelope) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type StartModelSyncResponseSchema struct {
	CreatedAt *time.Time `json:"created_at,omitempty" url:"created_at,omitempty"`
	// Execution ID
	Id     *string          `json:"id,omitempty" url:"id,omitempty"`
	Status *ExecutionStatus `json:"status,omitempty" url:"status,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *StartModelSyncResponseSchema) GetCreatedAt() *time.Time {
	if s == nil {
		return nil
	}
	return s.CreatedAt
}

func (s *StartModelSyncResponseSchema) GetId() *string {
	if s == nil {
		return nil
	}
	return s.Id
}

func (s *StartModelSyncResponseSchema) GetStatus() *ExecutionStatus {
	if s == nil {
		return nil
	}
	return s.Status
}

func (s *StartModelSyncResponseSchema) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StartModelSyncResponseSchema) UnmarshalJSON(data []byte) error {
	type embed StartModelSyncResponseSchema
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"created_at,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = StartModelSyncResponseSchema(unmarshaler.embed)
	s.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *StartModelSyncResponseSchema) MarshalJSON() ([]byte, error) {
	type embed StartModelSyncResponseSchema
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"created_at,omitempty"`
	}{
		embed:     embed(*s),
		CreatedAt: internal.NewOptionalDateTime(s.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (s *StartModelSyncResponseSchema) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SyncStatusEnvelope struct {
	Data *SyncStatusResponse `json:"data,omitempty" url:"data,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SyncStatusEnvelope) GetData() *SyncStatusResponse {
	if s == nil {
		return nil
	}
	return s.Data
}

func (s *SyncStatusEnvelope) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SyncStatusEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler SyncStatusEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SyncStatusEnvelope(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SyncStatusEnvelope) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SyncStatusResponse struct {
	CurrentExecution  *GetExecutionResponseSchema `json:"current_execution,omitempty" url:"current_execution,omitempty"`
	LastExecution     *GetExecutionResponseSchema `json:"last_execution,omitempty" url:"last_execution,omitempty"`
	NextExecutionTime *time.Time                  `json:"next_execution_time,omitempty" url:"next_execution_time,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SyncStatusResponse) GetCurrentExecution() *GetExecutionResponseSchema {
	if s == nil {
		return nil
	}
	return s.CurrentExecution
}

func (s *SyncStatusResponse) GetLastExecution() *GetExecutionResponseSchema {
	if s == nil {
		return nil
	}
	return s.LastExecution
}

func (s *SyncStatusResponse) GetNextExecutionTime() *time.Time {
	if s == nil {
		return nil
	}
	return s.NextExecutionTime
}

func (s *SyncStatusResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SyncStatusResponse) UnmarshalJSON(data []byte) error {
	type embed SyncStatusResponse
	var unmarshaler = struct {
		embed
		NextExecutionTime *internal.DateTime `json:"next_execution_time,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SyncStatusResponse(unmarshaler.embed)
	s.NextExecutionTime = unmarshaler.NextExecutionTime.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SyncStatusResponse) MarshalJSON() ([]byte, error) {
	type embed SyncStatusResponse
	var marshaler = struct {
		embed
		NextExecutionTime *internal.DateTime `json:"next_execution_time,omitempty"`
	}{
		embed:             embed(*s),
		NextExecutionTime: internal.NewOptionalDateTime(s.NextExecutionTime),
	}
	return json.Marshal(marshaler)
}

func (s *SyncStatusResponse) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type Target struct {
	Configuration map[string]interface{} `json:"configuration,omitempty" url:"configuration,omitempty"`
	ConnectionId  string                 `json:"connection_id" url:"connection_id"`
	// Create a new target object with these properties.
	Create      map[string]string `json:"create,omitempty" url:"create,omitempty"`
	FilterLogic *string           `json:"filter_logic,omitempty" url:"filter_logic,omitempty"`
	// Name for a new target object.
	NewName      *string                `json:"new_name,omitempty" url:"new_name,omitempty"`
	Object       *string                `json:"object,omitempty" url:"object,omitempty"`
	SearchValues map[string]interface{} `json:"search_values,omitempty" url:"search_values,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *Target) GetConfiguration() map[string]interface{} {
	if t == nil {
		return nil
	}
	return t.Configuration
}

func (t *Target) GetConnectionId() string {
	if t == nil {
		return ""
	}
	return t.ConnectionId
}

func (t *Target) GetCreate() map[string]string {
	if t == nil {
		return nil
	}
	return t.Create
}

func (t *Target) GetFilterLogic() *string {
	if t == nil {
		return nil
	}
	return t.FilterLogic
}

func (t *Target) GetNewName() *string {
	if t == nil {
		return nil
	}
	return t.NewName
}

func (t *Target) GetObject() *string {
	if t == nil {
		return nil
	}
	return t.Object
}

func (t *Target) GetSearchValues() map[string]interface{} {
	if t == nil {
		return nil
	}
	return t.SearchValues
}

func (t *Target) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Target) UnmarshalJSON(data []byte) error {
	type unmarshaler Target
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Target(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *Target) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}
