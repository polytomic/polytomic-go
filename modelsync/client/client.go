// This file was auto-generated by Fern from our API Definition.

package client

import (
	context "context"
	polytomicgo "github.com/polytomic/polytomic-go"
	core "github.com/polytomic/polytomic-go/core"
	internal "github.com/polytomic/polytomic-go/internal"
	executions "github.com/polytomic/polytomic-go/modelsync/executions"
	targets "github.com/polytomic/polytomic-go/modelsync/targets"
	option "github.com/polytomic/polytomic-go/option"
	http "net/http"
)

type Client struct {
	baseURL string
	caller  *internal.Caller
	header  http.Header

	Targets    *targets.Client
	Executions *executions.Client
}

func NewClient(opts ...option.RequestOption) *Client {
	options := core.NewRequestOptions(opts...)
	return &Client{
		baseURL: options.BaseURL,
		caller: internal.NewCaller(
			&internal.CallerParams{
				Client:      options.HTTPClient,
				MaxAttempts: options.MaxAttempts,
			},
		),
		header:     options.ToHeader(),
		Targets:    targets.NewClient(opts...),
		Executions: executions.NewClient(opts...),
	}
}

func (c *Client) GetSource(
	ctx context.Context,
	id string,
	request *polytomicgo.ModelSyncGetSourceRequest,
	opts ...option.RequestOption,
) (*polytomicgo.GetModelSyncSourceMetaEnvelope, error) {
	options := core.NewRequestOptions(opts...)
	baseURL := internal.ResolveBaseURL(
		options.BaseURL,
		c.baseURL,
		"https://app.polytomic.com",
	)
	endpointURL := internal.EncodeURL(
		baseURL+"/api/connections/%v/modelsync/source",
		id,
	)
	queryParams, err := internal.QueryValues(request)
	if err != nil {
		return nil, err
	}
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}
	headers := internal.MergeHeaders(
		c.header.Clone(),
		options.ToHeader(),
	)
	errorCodes := internal.ErrorCodes{
		400: func(apiError *core.APIError) error {
			return &polytomicgo.BadRequestError{
				APIError: apiError,
			}
		},
		401: func(apiError *core.APIError) error {
			return &polytomicgo.UnauthorizedError{
				APIError: apiError,
			}
		},
		403: func(apiError *core.APIError) error {
			return &polytomicgo.ForbiddenError{
				APIError: apiError,
			}
		},
		404: func(apiError *core.APIError) error {
			return &polytomicgo.NotFoundError{
				APIError: apiError,
			}
		},
		500: func(apiError *core.APIError) error {
			return &polytomicgo.InternalServerError{
				APIError: apiError,
			}
		},
	}

	var response *polytomicgo.GetModelSyncSourceMetaEnvelope
	if err := c.caller.Call(
		ctx,
		&internal.CallParams{
			URL:             endpointURL,
			Method:          http.MethodGet,
			Headers:         headers,
			MaxAttempts:     options.MaxAttempts,
			BodyProperties:  options.BodyProperties,
			QueryParameters: options.QueryParameters,
			Client:          options.HTTPClient,
			Response:        &response,
			ErrorDecoder:    internal.NewErrorDecoder(errorCodes),
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

func (c *Client) GetSourceFields(
	ctx context.Context,
	id string,
	request *polytomicgo.ModelSyncGetSourceFieldsRequest,
	opts ...option.RequestOption,
) (*polytomicgo.ModelFieldResponse, error) {
	options := core.NewRequestOptions(opts...)
	baseURL := internal.ResolveBaseURL(
		options.BaseURL,
		c.baseURL,
		"https://app.polytomic.com",
	)
	endpointURL := internal.EncodeURL(
		baseURL+"/api/connections/%v/modelsync/source/fields",
		id,
	)
	queryParams, err := internal.QueryValues(request)
	if err != nil {
		return nil, err
	}
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}
	headers := internal.MergeHeaders(
		c.header.Clone(),
		options.ToHeader(),
	)
	errorCodes := internal.ErrorCodes{
		400: func(apiError *core.APIError) error {
			return &polytomicgo.BadRequestError{
				APIError: apiError,
			}
		},
		401: func(apiError *core.APIError) error {
			return &polytomicgo.UnauthorizedError{
				APIError: apiError,
			}
		},
		403: func(apiError *core.APIError) error {
			return &polytomicgo.ForbiddenError{
				APIError: apiError,
			}
		},
		404: func(apiError *core.APIError) error {
			return &polytomicgo.NotFoundError{
				APIError: apiError,
			}
		},
		500: func(apiError *core.APIError) error {
			return &polytomicgo.InternalServerError{
				APIError: apiError,
			}
		},
	}

	var response *polytomicgo.ModelFieldResponse
	if err := c.caller.Call(
		ctx,
		&internal.CallParams{
			URL:             endpointURL,
			Method:          http.MethodGet,
			Headers:         headers,
			MaxAttempts:     options.MaxAttempts,
			BodyProperties:  options.BodyProperties,
			QueryParameters: options.QueryParameters,
			Client:          options.HTTPClient,
			Response:        &response,
			ErrorDecoder:    internal.NewErrorDecoder(errorCodes),
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

func (c *Client) List(
	ctx context.Context,
	request *polytomicgo.ModelSyncListRequest,
	opts ...option.RequestOption,
) (*polytomicgo.ListModelSyncResponseEnvelope, error) {
	options := core.NewRequestOptions(opts...)
	baseURL := internal.ResolveBaseURL(
		options.BaseURL,
		c.baseURL,
		"https://app.polytomic.com",
	)
	endpointURL := baseURL + "/api/syncs"
	queryParams, err := internal.QueryValues(request)
	if err != nil {
		return nil, err
	}
	if len(queryParams) > 0 {
		endpointURL += "?" + queryParams.Encode()
	}
	headers := internal.MergeHeaders(
		c.header.Clone(),
		options.ToHeader(),
	)
	errorCodes := internal.ErrorCodes{
		400: func(apiError *core.APIError) error {
			return &polytomicgo.BadRequestError{
				APIError: apiError,
			}
		},
		401: func(apiError *core.APIError) error {
			return &polytomicgo.UnauthorizedError{
				APIError: apiError,
			}
		},
		404: func(apiError *core.APIError) error {
			return &polytomicgo.NotFoundError{
				APIError: apiError,
			}
		},
		500: func(apiError *core.APIError) error {
			return &polytomicgo.InternalServerError{
				APIError: apiError,
			}
		},
	}

	var response *polytomicgo.ListModelSyncResponseEnvelope
	if err := c.caller.Call(
		ctx,
		&internal.CallParams{
			URL:             endpointURL,
			Method:          http.MethodGet,
			Headers:         headers,
			MaxAttempts:     options.MaxAttempts,
			BodyProperties:  options.BodyProperties,
			QueryParameters: options.QueryParameters,
			Client:          options.HTTPClient,
			Response:        &response,
			ErrorDecoder:    internal.NewErrorDecoder(errorCodes),
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// Create a new sync from one or more models to a destination.
//
// All of the functionality described in [the product
// documentation](https://docs.polytomic.com/docs/sync-destinations) is
// configurable via the API.
//
// Guides:
//
// - [Model sync (Reverse ETL) from Snowflake query to Salesforce](https://apidocs.polytomic.com/2024-02-08/guides/code-examples/model-sync-reverse-etl-from-snowflake-query-to-salesforce)
// - [Joined model sync from Postgres, Airtable, and Stripe to Hubspot](https://apidocs.polytomic.com/2024-02-08/guides/code-examples/joined-model-sync-from-postgres-airtable-and-stripe-to-hubspot)
//
// ## Targets (Destinations)
//
// Polytomic refers to a model sync's destination as the "target object", or
// target. Target objects are identified by a connection ID and an object ID. You
// can retrieve a list of all target objects for a connection using the [Get Target
// Objects](./targets/list) endpoint.
//
// The `target` object in the request specifies information about the sync destination.
//
// ```json
//
//	"target": {
//	    "connection_id": "248df4b7-aa70-47b8-a036-33ac447e668d",
//	    "object": "Users",
//	},
//
// ```
//
// Some connections support additional configuration for targets. For example,
// [Salesforce
// connections](https://apidocs.polytomic.com/2024-02-08/guides/configuring-your-connections/connections/salesforce#target)
// support optionally specifying the ingestion API to use. The target specific
// options are passed as `configuration`; consult the [integration
// guides](https://apidocs.polytomic.com/2024-02-08/guides/configuring-your-connections/overview)
// for details about specific connection configurations.
//
// ### Creating a new target
//
// Some integrations support creating a new target when creating a model sync. For
// example, an ad audience or database table.
//
// When creating a new target, `object` is omitted and `create` is specified
// instead. The `create` property is an object containing integration specific
// configuration for the new target.
//
// ```json
//
//	"target": {
//	    "connection_id": "248df4b7-aa70-47b8-a036-33ac447e668d",
//	    "create": {
//	        "name": "New audience",
//	        "type": "user_audience"
//	    }
//	},
//
// ```
//
// The [Get Target List](./targets/list) endpoint returns information about whether
// a connection supports target creation.
func (c *Client) Create(
	ctx context.Context,
	request *polytomicgo.CreateModelSyncRequest,
	opts ...option.RequestOption,
) (*polytomicgo.ModelSyncResponseEnvelope, error) {
	options := core.NewRequestOptions(opts...)
	baseURL := internal.ResolveBaseURL(
		options.BaseURL,
		c.baseURL,
		"https://app.polytomic.com",
	)
	endpointURL := baseURL + "/api/syncs"
	headers := internal.MergeHeaders(
		c.header.Clone(),
		options.ToHeader(),
	)
	headers.Set("Content-Type", "application/json")
	errorCodes := internal.ErrorCodes{
		400: func(apiError *core.APIError) error {
			return &polytomicgo.BadRequestError{
				APIError: apiError,
			}
		},
		401: func(apiError *core.APIError) error {
			return &polytomicgo.UnauthorizedError{
				APIError: apiError,
			}
		},
		403: func(apiError *core.APIError) error {
			return &polytomicgo.ForbiddenError{
				APIError: apiError,
			}
		},
		422: func(apiError *core.APIError) error {
			return &polytomicgo.UnprocessableEntityError{
				APIError: apiError,
			}
		},
		500: func(apiError *core.APIError) error {
			return &polytomicgo.InternalServerError{
				APIError: apiError,
			}
		},
	}

	var response *polytomicgo.ModelSyncResponseEnvelope
	if err := c.caller.Call(
		ctx,
		&internal.CallParams{
			URL:             endpointURL,
			Method:          http.MethodPost,
			Headers:         headers,
			MaxAttempts:     options.MaxAttempts,
			BodyProperties:  options.BodyProperties,
			QueryParameters: options.QueryParameters,
			Client:          options.HTTPClient,
			Request:         request,
			Response:        &response,
			ErrorDecoder:    internal.NewErrorDecoder(errorCodes),
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

func (c *Client) GetScheduleOptions(
	ctx context.Context,
	opts ...option.RequestOption,
) (*polytomicgo.ScheduleOptionResponseEnvelope, error) {
	options := core.NewRequestOptions(opts...)
	baseURL := internal.ResolveBaseURL(
		options.BaseURL,
		c.baseURL,
		"https://app.polytomic.com",
	)
	endpointURL := baseURL + "/api/syncs/schedules"
	headers := internal.MergeHeaders(
		c.header.Clone(),
		options.ToHeader(),
	)
	errorCodes := internal.ErrorCodes{
		401: func(apiError *core.APIError) error {
			return &polytomicgo.UnauthorizedError{
				APIError: apiError,
			}
		},
		500: func(apiError *core.APIError) error {
			return &polytomicgo.InternalServerError{
				APIError: apiError,
			}
		},
	}

	var response *polytomicgo.ScheduleOptionResponseEnvelope
	if err := c.caller.Call(
		ctx,
		&internal.CallParams{
			URL:             endpointURL,
			Method:          http.MethodGet,
			Headers:         headers,
			MaxAttempts:     options.MaxAttempts,
			BodyProperties:  options.BodyProperties,
			QueryParameters: options.QueryParameters,
			Client:          options.HTTPClient,
			Response:        &response,
			ErrorDecoder:    internal.NewErrorDecoder(errorCodes),
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

func (c *Client) Get(
	ctx context.Context,
	id string,
	opts ...option.RequestOption,
) (*polytomicgo.ModelSyncResponseEnvelope, error) {
	options := core.NewRequestOptions(opts...)
	baseURL := internal.ResolveBaseURL(
		options.BaseURL,
		c.baseURL,
		"https://app.polytomic.com",
	)
	endpointURL := internal.EncodeURL(
		baseURL+"/api/syncs/%v",
		id,
	)
	headers := internal.MergeHeaders(
		c.header.Clone(),
		options.ToHeader(),
	)
	errorCodes := internal.ErrorCodes{
		401: func(apiError *core.APIError) error {
			return &polytomicgo.UnauthorizedError{
				APIError: apiError,
			}
		},
		404: func(apiError *core.APIError) error {
			return &polytomicgo.NotFoundError{
				APIError: apiError,
			}
		},
		500: func(apiError *core.APIError) error {
			return &polytomicgo.InternalServerError{
				APIError: apiError,
			}
		},
	}

	var response *polytomicgo.ModelSyncResponseEnvelope
	if err := c.caller.Call(
		ctx,
		&internal.CallParams{
			URL:             endpointURL,
			Method:          http.MethodGet,
			Headers:         headers,
			MaxAttempts:     options.MaxAttempts,
			BodyProperties:  options.BodyProperties,
			QueryParameters: options.QueryParameters,
			Client:          options.HTTPClient,
			Response:        &response,
			ErrorDecoder:    internal.NewErrorDecoder(errorCodes),
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

func (c *Client) Update(
	ctx context.Context,
	id string,
	request *polytomicgo.UpdateModelSyncRequest,
	opts ...option.RequestOption,
) (*polytomicgo.ModelSyncResponseEnvelope, error) {
	options := core.NewRequestOptions(opts...)
	baseURL := internal.ResolveBaseURL(
		options.BaseURL,
		c.baseURL,
		"https://app.polytomic.com",
	)
	endpointURL := internal.EncodeURL(
		baseURL+"/api/syncs/%v",
		id,
	)
	headers := internal.MergeHeaders(
		c.header.Clone(),
		options.ToHeader(),
	)
	headers.Set("Content-Type", "application/json")
	errorCodes := internal.ErrorCodes{
		400: func(apiError *core.APIError) error {
			return &polytomicgo.BadRequestError{
				APIError: apiError,
			}
		},
		401: func(apiError *core.APIError) error {
			return &polytomicgo.UnauthorizedError{
				APIError: apiError,
			}
		},
		403: func(apiError *core.APIError) error {
			return &polytomicgo.ForbiddenError{
				APIError: apiError,
			}
		},
		404: func(apiError *core.APIError) error {
			return &polytomicgo.NotFoundError{
				APIError: apiError,
			}
		},
		422: func(apiError *core.APIError) error {
			return &polytomicgo.UnprocessableEntityError{
				APIError: apiError,
			}
		},
		500: func(apiError *core.APIError) error {
			return &polytomicgo.InternalServerError{
				APIError: apiError,
			}
		},
	}

	var response *polytomicgo.ModelSyncResponseEnvelope
	if err := c.caller.Call(
		ctx,
		&internal.CallParams{
			URL:             endpointURL,
			Method:          http.MethodPut,
			Headers:         headers,
			MaxAttempts:     options.MaxAttempts,
			BodyProperties:  options.BodyProperties,
			QueryParameters: options.QueryParameters,
			Client:          options.HTTPClient,
			Request:         request,
			Response:        &response,
			ErrorDecoder:    internal.NewErrorDecoder(errorCodes),
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

func (c *Client) Remove(
	ctx context.Context,
	id string,
	opts ...option.RequestOption,
) error {
	options := core.NewRequestOptions(opts...)
	baseURL := internal.ResolveBaseURL(
		options.BaseURL,
		c.baseURL,
		"https://app.polytomic.com",
	)
	endpointURL := internal.EncodeURL(
		baseURL+"/api/syncs/%v",
		id,
	)
	headers := internal.MergeHeaders(
		c.header.Clone(),
		options.ToHeader(),
	)
	errorCodes := internal.ErrorCodes{
		401: func(apiError *core.APIError) error {
			return &polytomicgo.UnauthorizedError{
				APIError: apiError,
			}
		},
		403: func(apiError *core.APIError) error {
			return &polytomicgo.ForbiddenError{
				APIError: apiError,
			}
		},
		404: func(apiError *core.APIError) error {
			return &polytomicgo.NotFoundError{
				APIError: apiError,
			}
		},
		409: func(apiError *core.APIError) error {
			return &polytomicgo.ConflictError{
				APIError: apiError,
			}
		},
		500: func(apiError *core.APIError) error {
			return &polytomicgo.InternalServerError{
				APIError: apiError,
			}
		},
	}

	if err := c.caller.Call(
		ctx,
		&internal.CallParams{
			URL:             endpointURL,
			Method:          http.MethodDelete,
			Headers:         headers,
			MaxAttempts:     options.MaxAttempts,
			BodyProperties:  options.BodyProperties,
			QueryParameters: options.QueryParameters,
			Client:          options.HTTPClient,
			ErrorDecoder:    internal.NewErrorDecoder(errorCodes),
		},
	); err != nil {
		return err
	}
	return nil
}

func (c *Client) Activate(
	ctx context.Context,
	id string,
	request *polytomicgo.ModelSyncActivateRequest,
	opts ...option.RequestOption,
) (*polytomicgo.ActivateSyncEnvelope, error) {
	options := core.NewRequestOptions(opts...)
	baseURL := internal.ResolveBaseURL(
		options.BaseURL,
		c.baseURL,
		"https://app.polytomic.com",
	)
	endpointURL := internal.EncodeURL(
		baseURL+"/api/syncs/%v/activate",
		id,
	)
	headers := internal.MergeHeaders(
		c.header.Clone(),
		options.ToHeader(),
	)
	headers.Set("Content-Type", "application/json")
	errorCodes := internal.ErrorCodes{
		401: func(apiError *core.APIError) error {
			return &polytomicgo.UnauthorizedError{
				APIError: apiError,
			}
		},
		403: func(apiError *core.APIError) error {
			return &polytomicgo.ForbiddenError{
				APIError: apiError,
			}
		},
		404: func(apiError *core.APIError) error {
			return &polytomicgo.NotFoundError{
				APIError: apiError,
			}
		},
		500: func(apiError *core.APIError) error {
			return &polytomicgo.InternalServerError{
				APIError: apiError,
			}
		},
	}

	var response *polytomicgo.ActivateSyncEnvelope
	if err := c.caller.Call(
		ctx,
		&internal.CallParams{
			URL:             endpointURL,
			Method:          http.MethodPost,
			Headers:         headers,
			MaxAttempts:     options.MaxAttempts,
			BodyProperties:  options.BodyProperties,
			QueryParameters: options.QueryParameters,
			Client:          options.HTTPClient,
			Request:         request,
			Response:        &response,
			ErrorDecoder:    internal.NewErrorDecoder(errorCodes),
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

func (c *Client) Cancel(
	ctx context.Context,
	// The active execution of this sync ID will be cancelled.
	id string,
	opts ...option.RequestOption,
) (*polytomicgo.CancelModelSyncResponseEnvelope, error) {
	options := core.NewRequestOptions(opts...)
	baseURL := internal.ResolveBaseURL(
		options.BaseURL,
		c.baseURL,
		"https://app.polytomic.com",
	)
	endpointURL := internal.EncodeURL(
		baseURL+"/api/syncs/%v/cancel",
		id,
	)
	headers := internal.MergeHeaders(
		c.header.Clone(),
		options.ToHeader(),
	)
	errorCodes := internal.ErrorCodes{
		401: func(apiError *core.APIError) error {
			return &polytomicgo.UnauthorizedError{
				APIError: apiError,
			}
		},
		403: func(apiError *core.APIError) error {
			return &polytomicgo.ForbiddenError{
				APIError: apiError,
			}
		},
		404: func(apiError *core.APIError) error {
			return &polytomicgo.NotFoundError{
				APIError: apiError,
			}
		},
		500: func(apiError *core.APIError) error {
			return &polytomicgo.InternalServerError{
				APIError: apiError,
			}
		},
	}

	var response *polytomicgo.CancelModelSyncResponseEnvelope
	if err := c.caller.Call(
		ctx,
		&internal.CallParams{
			URL:             endpointURL,
			Method:          http.MethodPost,
			Headers:         headers,
			MaxAttempts:     options.MaxAttempts,
			BodyProperties:  options.BodyProperties,
			QueryParameters: options.QueryParameters,
			Client:          options.HTTPClient,
			Response:        &response,
			ErrorDecoder:    internal.NewErrorDecoder(errorCodes),
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

// > ðŸš§ Force full resync
// >
// > Use caution when setting the `resync` parameter to `true`. This will force a full resync of the data from the source system. This can be a time-consuming operation and may impact the performance of the source system. It is recommended to only use this option when necessary.
func (c *Client) Start(
	ctx context.Context,
	id string,
	request *polytomicgo.StartModelSyncRequest,
	opts ...option.RequestOption,
) (*polytomicgo.StartModelSyncResponseEnvelope, error) {
	options := core.NewRequestOptions(opts...)
	baseURL := internal.ResolveBaseURL(
		options.BaseURL,
		c.baseURL,
		"https://app.polytomic.com",
	)
	endpointURL := internal.EncodeURL(
		baseURL+"/api/syncs/%v/executions",
		id,
	)
	headers := internal.MergeHeaders(
		c.header.Clone(),
		options.ToHeader(),
	)
	headers.Set("Content-Type", "application/json")
	errorCodes := internal.ErrorCodes{
		400: func(apiError *core.APIError) error {
			return &polytomicgo.BadRequestError{
				APIError: apiError,
			}
		},
		401: func(apiError *core.APIError) error {
			return &polytomicgo.UnauthorizedError{
				APIError: apiError,
			}
		},
		403: func(apiError *core.APIError) error {
			return &polytomicgo.ForbiddenError{
				APIError: apiError,
			}
		},
		404: func(apiError *core.APIError) error {
			return &polytomicgo.NotFoundError{
				APIError: apiError,
			}
		},
		409: func(apiError *core.APIError) error {
			return &polytomicgo.ConflictError{
				APIError: apiError,
			}
		},
		500: func(apiError *core.APIError) error {
			return &polytomicgo.InternalServerError{
				APIError: apiError,
			}
		},
	}

	var response *polytomicgo.StartModelSyncResponseEnvelope
	if err := c.caller.Call(
		ctx,
		&internal.CallParams{
			URL:             endpointURL,
			Method:          http.MethodPost,
			Headers:         headers,
			MaxAttempts:     options.MaxAttempts,
			BodyProperties:  options.BodyProperties,
			QueryParameters: options.QueryParameters,
			Client:          options.HTTPClient,
			Request:         request,
			Response:        &response,
			ErrorDecoder:    internal.NewErrorDecoder(errorCodes),
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}

func (c *Client) GetStatus(
	ctx context.Context,
	id string,
	opts ...option.RequestOption,
) (*polytomicgo.SyncStatusEnvelope, error) {
	options := core.NewRequestOptions(opts...)
	baseURL := internal.ResolveBaseURL(
		options.BaseURL,
		c.baseURL,
		"https://app.polytomic.com",
	)
	endpointURL := internal.EncodeURL(
		baseURL+"/api/syncs/%v/status",
		id,
	)
	headers := internal.MergeHeaders(
		c.header.Clone(),
		options.ToHeader(),
	)
	errorCodes := internal.ErrorCodes{
		401: func(apiError *core.APIError) error {
			return &polytomicgo.UnauthorizedError{
				APIError: apiError,
			}
		},
		404: func(apiError *core.APIError) error {
			return &polytomicgo.NotFoundError{
				APIError: apiError,
			}
		},
		500: func(apiError *core.APIError) error {
			return &polytomicgo.InternalServerError{
				APIError: apiError,
			}
		},
	}

	var response *polytomicgo.SyncStatusEnvelope
	if err := c.caller.Call(
		ctx,
		&internal.CallParams{
			URL:             endpointURL,
			Method:          http.MethodGet,
			Headers:         headers,
			MaxAttempts:     options.MaxAttempts,
			BodyProperties:  options.BodyProperties,
			QueryParameters: options.QueryParameters,
			Client:          options.HTTPClient,
			Response:        &response,
			ErrorDecoder:    internal.NewErrorDecoder(errorCodes),
		},
	); err != nil {
		return nil, err
	}
	return response, nil
}
