// This file was auto-generated by Fern from our API Definition.

package polytomic

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/polytomic/polytomic-go/core"
	time "time"
)

type ActivateSyncEnvelope struct {
	Data *ActivateSyncOutput `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (a *ActivateSyncEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler ActivateSyncEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActivateSyncEnvelope(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActivateSyncEnvelope) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ActivateSyncInput struct {
	Active bool `json:"active" url:"active"`

	_rawJSON json.RawMessage
}

func (a *ActivateSyncInput) UnmarshalJSON(data []byte) error {
	type unmarshaler ActivateSyncInput
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActivateSyncInput(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActivateSyncInput) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ActivateSyncOutput struct {
	Active *bool   `json:"active,omitempty" url:"active,omitempty"`
	Id     *string `json:"id,omitempty" url:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (a *ActivateSyncOutput) UnmarshalJSON(data []byte) error {
	type unmarshaler ActivateSyncOutput
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActivateSyncOutput(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActivateSyncOutput) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApiError struct {
	Key      *string                `json:"key,omitempty" url:"key,omitempty"`
	Message  *string                `json:"message,omitempty" url:"message,omitempty"`
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	Status   *int                   `json:"status,omitempty" url:"status,omitempty"`

	_rawJSON json.RawMessage
}

func (a *ApiError) UnmarshalJSON(data []byte) error {
	type unmarshaler ApiError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApiError(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApiError) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type BulkExecutionStatus string

const (
	BulkExecutionStatusCreated    BulkExecutionStatus = "created"
	BulkExecutionStatusScheduled  BulkExecutionStatus = "scheduled"
	BulkExecutionStatusRunning    BulkExecutionStatus = "running"
	BulkExecutionStatusExporting  BulkExecutionStatus = "exporting"
	BulkExecutionStatusCanceling  BulkExecutionStatus = "canceling"
	BulkExecutionStatusCanceled   BulkExecutionStatus = "canceled"
	BulkExecutionStatusCompleted  BulkExecutionStatus = "completed"
	BulkExecutionStatusFailed     BulkExecutionStatus = "failed"
	BulkExecutionStatusProcessing BulkExecutionStatus = "processing"
	BulkExecutionStatusErrors     BulkExecutionStatus = "errors"
)

func NewBulkExecutionStatusFromString(s string) (BulkExecutionStatus, error) {
	switch s {
	case "created":
		return BulkExecutionStatusCreated, nil
	case "scheduled":
		return BulkExecutionStatusScheduled, nil
	case "running":
		return BulkExecutionStatusRunning, nil
	case "exporting":
		return BulkExecutionStatusExporting, nil
	case "canceling":
		return BulkExecutionStatusCanceling, nil
	case "canceled":
		return BulkExecutionStatusCanceled, nil
	case "completed":
		return BulkExecutionStatusCompleted, nil
	case "failed":
		return BulkExecutionStatusFailed, nil
	case "processing":
		return BulkExecutionStatusProcessing, nil
	case "errors":
		return BulkExecutionStatusErrors, nil
	}
	var t BulkExecutionStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BulkExecutionStatus) Ptr() *BulkExecutionStatus {
	return &b
}

// How the data is fetched. 'none' is normal operation for Polytomic. 'incremental' and 'full' apply to syncs from Salesforce. 'incremental' indicates the data is synced incrementally using record modification time. 'full' is necessary to catch up to the latest values for formula fields and rollup fields whose updates don't show up in incremental runs due to limitations in Salesforce.
type BulkFetchMode string

const (
	BulkFetchModeNone        BulkFetchMode = "none"
	BulkFetchModeIncremental BulkFetchMode = "incremental"
	BulkFetchModeFull        BulkFetchMode = "full"
)

func NewBulkFetchModeFromString(s string) (BulkFetchMode, error) {
	switch s {
	case "none":
		return BulkFetchModeNone, nil
	case "incremental":
		return BulkFetchModeIncremental, nil
	case "full":
		return BulkFetchModeFull, nil
	}
	var t BulkFetchMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BulkFetchMode) Ptr() *BulkFetchMode {
	return &b
}

type BulkField struct {
	Enabled    *bool   `json:"enabled,omitempty" url:"enabled,omitempty"`
	Id         *string `json:"id,omitempty" url:"id,omitempty"`
	Obfuscated *bool   `json:"obfuscated,omitempty" url:"obfuscated,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BulkField) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkField(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkField) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BulkFilter struct {
	// Schema field ID to filter on.
	FieldId  *string        `json:"field_id,omitempty" url:"field_id,omitempty"`
	Function FilterFunction `json:"function,omitempty" url:"function,omitempty"`
	Value    interface{}    `json:"value,omitempty" url:"value,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BulkFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkFilter(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkFilter) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BulkSchema struct {
	DataCutoffTimestamp *time.Time    `json:"data_cutoff_timestamp,omitempty" url:"data_cutoff_timestamp,omitempty"`
	DisableDataCutoff   *bool         `json:"disable_data_cutoff,omitempty" url:"disable_data_cutoff,omitempty"`
	Enabled             *bool         `json:"enabled,omitempty" url:"enabled,omitempty"`
	Fields              []*BulkField  `json:"fields,omitempty" url:"fields,omitempty"`
	Filters             []*BulkFilter `json:"filters,omitempty" url:"filters,omitempty"`
	Id                  *string       `json:"id,omitempty" url:"id,omitempty"`
	OutputName          *string       `json:"output_name,omitempty" url:"output_name,omitempty"`
	PartitionKey        *string       `json:"partition_key,omitempty" url:"partition_key,omitempty"`
	TrackingField       *string       `json:"tracking_field,omitempty" url:"tracking_field,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BulkSchema) UnmarshalJSON(data []byte) error {
	type embed BulkSchema
	var unmarshaler = struct {
		embed
		DataCutoffTimestamp *core.DateTime `json:"data_cutoff_timestamp,omitempty"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BulkSchema(unmarshaler.embed)
	b.DataCutoffTimestamp = unmarshaler.DataCutoffTimestamp.TimePtr()
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkSchema) MarshalJSON() ([]byte, error) {
	type embed BulkSchema
	var marshaler = struct {
		embed
		DataCutoffTimestamp *core.DateTime `json:"data_cutoff_timestamp,omitempty"`
	}{
		embed:               embed(*b),
		DataCutoffTimestamp: core.NewOptionalDateTime(b.DataCutoffTimestamp),
	}
	return json.Marshal(marshaler)
}

func (b *BulkSchema) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BulkSchemaEnvelope struct {
	Data *BulkSchema `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BulkSchemaEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkSchemaEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkSchemaEnvelope(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkSchemaEnvelope) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BulkSchemaExecutionStatus string

const (
	BulkSchemaExecutionStatusCreated   BulkSchemaExecutionStatus = "created"
	BulkSchemaExecutionStatusScheduled BulkSchemaExecutionStatus = "scheduled"
	BulkSchemaExecutionStatusRunning   BulkSchemaExecutionStatus = "running"
	BulkSchemaExecutionStatusExporting BulkSchemaExecutionStatus = "exporting"
	BulkSchemaExecutionStatusCanceled  BulkSchemaExecutionStatus = "canceled"
	BulkSchemaExecutionStatusCompleted BulkSchemaExecutionStatus = "completed"
	BulkSchemaExecutionStatusFailed    BulkSchemaExecutionStatus = "failed"
)

func NewBulkSchemaExecutionStatusFromString(s string) (BulkSchemaExecutionStatus, error) {
	switch s {
	case "created":
		return BulkSchemaExecutionStatusCreated, nil
	case "scheduled":
		return BulkSchemaExecutionStatusScheduled, nil
	case "running":
		return BulkSchemaExecutionStatusRunning, nil
	case "exporting":
		return BulkSchemaExecutionStatusExporting, nil
	case "canceled":
		return BulkSchemaExecutionStatusCanceled, nil
	case "completed":
		return BulkSchemaExecutionStatusCompleted, nil
	case "failed":
		return BulkSchemaExecutionStatusFailed, nil
	}
	var t BulkSchemaExecutionStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BulkSchemaExecutionStatus) Ptr() *BulkSchemaExecutionStatus {
	return &b
}

type BulkSyncExecution struct {
	CompletedAt *time.Time                 `json:"completed_at,omitempty" url:"completed_at,omitempty"`
	CreatedAt   *time.Time                 `json:"created_at,omitempty" url:"created_at,omitempty"`
	FetchMode   *BulkFetchMode             `json:"fetch_mode,omitempty" url:"fetch_mode,omitempty"`
	Id          *string                    `json:"id,omitempty" url:"id,omitempty"`
	IsResync    *bool                      `json:"is_resync,omitempty" url:"is_resync,omitempty"`
	IsTest      *bool                      `json:"is_test,omitempty" url:"is_test,omitempty"`
	Schemas     []*BulkSyncSchemaExecution `json:"schemas,omitempty" url:"schemas,omitempty"`
	StartedAt   *time.Time                 `json:"started_at,omitempty" url:"started_at,omitempty"`
	Status      *BulkExecutionStatus       `json:"status,omitempty" url:"status,omitempty"`
	Type        *string                    `json:"type,omitempty" url:"type,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BulkSyncExecution) UnmarshalJSON(data []byte) error {
	type embed BulkSyncExecution
	var unmarshaler = struct {
		embed
		CompletedAt *core.DateTime `json:"completed_at,omitempty"`
		CreatedAt   *core.DateTime `json:"created_at,omitempty"`
		StartedAt   *core.DateTime `json:"started_at,omitempty"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BulkSyncExecution(unmarshaler.embed)
	b.CompletedAt = unmarshaler.CompletedAt.TimePtr()
	b.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	b.StartedAt = unmarshaler.StartedAt.TimePtr()
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkSyncExecution) MarshalJSON() ([]byte, error) {
	type embed BulkSyncExecution
	var marshaler = struct {
		embed
		CompletedAt *core.DateTime `json:"completed_at,omitempty"`
		CreatedAt   *core.DateTime `json:"created_at,omitempty"`
		StartedAt   *core.DateTime `json:"started_at,omitempty"`
	}{
		embed:       embed(*b),
		CompletedAt: core.NewOptionalDateTime(b.CompletedAt),
		CreatedAt:   core.NewOptionalDateTime(b.CreatedAt),
		StartedAt:   core.NewOptionalDateTime(b.StartedAt),
	}
	return json.Marshal(marshaler)
}

func (b *BulkSyncExecution) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BulkSyncExecutionEnvelope struct {
	Data *BulkSyncExecution `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BulkSyncExecutionEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkSyncExecutionEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkSyncExecutionEnvelope(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkSyncExecutionEnvelope) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BulkSyncExecutionStatus struct {
	NextExecutionTime *time.Time                       `json:"nextExecutionTime,omitempty" url:"nextExecutionTime,omitempty"`
	Schemas           []*BulkSyncSchemaExecutionStatus `json:"schemas,omitempty" url:"schemas,omitempty"`
	Status            *BulkExecutionStatus             `json:"status,omitempty" url:"status,omitempty"`
	SyncId            *string                          `json:"sync_id,omitempty" url:"sync_id,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BulkSyncExecutionStatus) UnmarshalJSON(data []byte) error {
	type embed BulkSyncExecutionStatus
	var unmarshaler = struct {
		embed
		NextExecutionTime *core.DateTime `json:"nextExecutionTime,omitempty"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BulkSyncExecutionStatus(unmarshaler.embed)
	b.NextExecutionTime = unmarshaler.NextExecutionTime.TimePtr()
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkSyncExecutionStatus) MarshalJSON() ([]byte, error) {
	type embed BulkSyncExecutionStatus
	var marshaler = struct {
		embed
		NextExecutionTime *core.DateTime `json:"nextExecutionTime,omitempty"`
	}{
		embed:             embed(*b),
		NextExecutionTime: core.NewOptionalDateTime(b.NextExecutionTime),
	}
	return json.Marshal(marshaler)
}

func (b *BulkSyncExecutionStatus) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BulkSyncSchemaExecution struct {
	CompletedAt   *time.Time                 `json:"completed_at,omitempty" url:"completed_at,omitempty"`
	ErrorCount    *int                       `json:"error_count,omitempty" url:"error_count,omitempty"`
	RecordCount   *int                       `json:"record_count,omitempty" url:"record_count,omitempty"`
	Schema        *string                    `json:"schema,omitempty" url:"schema,omitempty"`
	StartedAt     *time.Time                 `json:"started_at,omitempty" url:"started_at,omitempty"`
	Status        *BulkSchemaExecutionStatus `json:"status,omitempty" url:"status,omitempty"`
	StatusMessage *string                    `json:"status_message,omitempty" url:"status_message,omitempty"`
	WarningCount  *int                       `json:"warning_count,omitempty" url:"warning_count,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BulkSyncSchemaExecution) UnmarshalJSON(data []byte) error {
	type embed BulkSyncSchemaExecution
	var unmarshaler = struct {
		embed
		CompletedAt *core.DateTime `json:"completed_at,omitempty"`
		StartedAt   *core.DateTime `json:"started_at,omitempty"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BulkSyncSchemaExecution(unmarshaler.embed)
	b.CompletedAt = unmarshaler.CompletedAt.TimePtr()
	b.StartedAt = unmarshaler.StartedAt.TimePtr()
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkSyncSchemaExecution) MarshalJSON() ([]byte, error) {
	type embed BulkSyncSchemaExecution
	var marshaler = struct {
		embed
		CompletedAt *core.DateTime `json:"completed_at,omitempty"`
		StartedAt   *core.DateTime `json:"started_at,omitempty"`
	}{
		embed:       embed(*b),
		CompletedAt: core.NewOptionalDateTime(b.CompletedAt),
		StartedAt:   core.NewOptionalDateTime(b.StartedAt),
	}
	return json.Marshal(marshaler)
}

func (b *BulkSyncSchemaExecution) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BulkSyncSchemaExecutionStatus struct {
	CompletedAt *time.Time `json:"completed_at,omitempty" url:"completed_at,omitempty"`
	ErrorCount  *int       `json:"error_count,omitempty" url:"error_count,omitempty"`
	// ID of the most recent execution for the schema.
	ExecutionId   *string                    `json:"execution_id,omitempty" url:"execution_id,omitempty"`
	RecordCount   *int                       `json:"record_count,omitempty" url:"record_count,omitempty"`
	Schema        *string                    `json:"schema,omitempty" url:"schema,omitempty"`
	StartedAt     *time.Time                 `json:"started_at,omitempty" url:"started_at,omitempty"`
	Status        *BulkSchemaExecutionStatus `json:"status,omitempty" url:"status,omitempty"`
	StatusMessage *string                    `json:"status_message,omitempty" url:"status_message,omitempty"`
	WarningCount  *int                       `json:"warning_count,omitempty" url:"warning_count,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BulkSyncSchemaExecutionStatus) UnmarshalJSON(data []byte) error {
	type embed BulkSyncSchemaExecutionStatus
	var unmarshaler = struct {
		embed
		CompletedAt *core.DateTime `json:"completed_at,omitempty"`
		StartedAt   *core.DateTime `json:"started_at,omitempty"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BulkSyncSchemaExecutionStatus(unmarshaler.embed)
	b.CompletedAt = unmarshaler.CompletedAt.TimePtr()
	b.StartedAt = unmarshaler.StartedAt.TimePtr()
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkSyncSchemaExecutionStatus) MarshalJSON() ([]byte, error) {
	type embed BulkSyncSchemaExecutionStatus
	var marshaler = struct {
		embed
		CompletedAt *core.DateTime `json:"completed_at,omitempty"`
		StartedAt   *core.DateTime `json:"started_at,omitempty"`
	}{
		embed:       embed(*b),
		CompletedAt: core.NewOptionalDateTime(b.CompletedAt),
		StartedAt:   core.NewOptionalDateTime(b.StartedAt),
	}
	return json.Marshal(marshaler)
}

func (b *BulkSyncSchemaExecutionStatus) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type CommonOutputActor struct {
	Id   *string `json:"id,omitempty" url:"id,omitempty"`
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	Type *string `json:"type,omitempty" url:"type,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CommonOutputActor) UnmarshalJSON(data []byte) error {
	type unmarshaler CommonOutputActor
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CommonOutputActor(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CommonOutputActor) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConfigurationValue struct {
	Items []interface{} `json:"items,omitempty" url:"items,omitempty"`
	Type  *string       `json:"type,omitempty" url:"type,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ConfigurationValue) UnmarshalJSON(data []byte) error {
	type unmarshaler ConfigurationValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConfigurationValue(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConfigurationValue) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type Enrichment struct {
	Configuration *V2EnricherConfiguration `json:"configuration,omitempty" url:"configuration,omitempty"`
	ConnectionId  *string                  `json:"connection_id,omitempty" url:"connection_id,omitempty"`
	// Must be provided to update an existing enrichment
	EnricherId *string `json:"enricher_id,omitempty" url:"enricher_id,omitempty"`
	// If not provided, all fields will be enabled.
	Fields   []*ModelField      `json:"fields,omitempty" url:"fields,omitempty"`
	Mappings *V2EnricherMapping `json:"mappings,omitempty" url:"mappings,omitempty"`

	_rawJSON json.RawMessage
}

func (e *Enrichment) UnmarshalJSON(data []byte) error {
	type unmarshaler Enrichment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Enrichment(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *Enrichment) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExecutionCounts struct {
	Delete *int `json:"delete,omitempty" url:"delete,omitempty"`
	Error  *int `json:"error,omitempty" url:"error,omitempty"`
	Insert *int `json:"insert,omitempty" url:"insert,omitempty"`
	Total  *int `json:"total,omitempty" url:"total,omitempty"`
	Update *int `json:"update,omitempty" url:"update,omitempty"`

	_rawJSON json.RawMessage
}

func (e *ExecutionCounts) UnmarshalJSON(data []byte) error {
	type unmarshaler ExecutionCounts
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExecutionCounts(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ExecutionCounts) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExecutionLogResponse struct {
	Expires *time.Time `json:"expires,omitempty" url:"expires,omitempty"`
	Urls    []string   `json:"urls,omitempty" url:"urls,omitempty"`

	_rawJSON json.RawMessage
}

func (e *ExecutionLogResponse) UnmarshalJSON(data []byte) error {
	type embed ExecutionLogResponse
	var unmarshaler = struct {
		embed
		Expires *core.DateTime `json:"expires,omitempty"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = ExecutionLogResponse(unmarshaler.embed)
	e.Expires = unmarshaler.Expires.TimePtr()
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ExecutionLogResponse) MarshalJSON() ([]byte, error) {
	type embed ExecutionLogResponse
	var marshaler = struct {
		embed
		Expires *core.DateTime `json:"expires,omitempty"`
	}{
		embed:   embed(*e),
		Expires: core.NewOptionalDateTime(e.Expires),
	}
	return json.Marshal(marshaler)
}

func (e *ExecutionLogResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExecutionLogsResponseEnvelope struct {
	Data *ExecutionLogResponse `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (e *ExecutionLogsResponseEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler ExecutionLogsResponseEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExecutionLogsResponseEnvelope(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ExecutionLogsResponseEnvelope) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExecutionStatus string

const (
	ExecutionStatusCreated     ExecutionStatus = "created"
	ExecutionStatusScheduled   ExecutionStatus = "scheduled"
	ExecutionStatusQueued      ExecutionStatus = "queued"
	ExecutionStatusWaiting     ExecutionStatus = "waiting"
	ExecutionStatusRunning     ExecutionStatus = "running"
	ExecutionStatusProcessing  ExecutionStatus = "processing"
	ExecutionStatusCanceling   ExecutionStatus = "canceling"
	ExecutionStatusCanceled    ExecutionStatus = "canceled"
	ExecutionStatusCompleted   ExecutionStatus = "completed"
	ExecutionStatusFailed      ExecutionStatus = "failed"
	ExecutionStatusInterrupted ExecutionStatus = "interrupted"
)

func NewExecutionStatusFromString(s string) (ExecutionStatus, error) {
	switch s {
	case "created":
		return ExecutionStatusCreated, nil
	case "scheduled":
		return ExecutionStatusScheduled, nil
	case "queued":
		return ExecutionStatusQueued, nil
	case "waiting":
		return ExecutionStatusWaiting, nil
	case "running":
		return ExecutionStatusRunning, nil
	case "processing":
		return ExecutionStatusProcessing, nil
	case "canceling":
		return ExecutionStatusCanceling, nil
	case "canceled":
		return ExecutionStatusCanceled, nil
	case "completed":
		return ExecutionStatusCompleted, nil
	case "failed":
		return ExecutionStatusFailed, nil
	case "interrupted":
		return ExecutionStatusInterrupted, nil
	}
	var t ExecutionStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e ExecutionStatus) Ptr() *ExecutionStatus {
	return &e
}

type FilterFunction string

const (
	FilterFunctionEquality             FilterFunction = "Equality"
	FilterFunctionInequality           FilterFunction = "Inequality"
	FilterFunctionIsNull               FilterFunction = "IsNull"
	FilterFunctionIsNotNull            FilterFunction = "IsNotNull"
	FilterFunctionTrue                 FilterFunction = "True"
	FilterFunctionFalse                FilterFunction = "False"
	FilterFunctionOnOrAfter            FilterFunction = "OnOrAfter"
	FilterFunctionOnOrBefore           FilterFunction = "OnOrBefore"
	FilterFunctionGreaterThan          FilterFunction = "GreaterThan"
	FilterFunctionGreaterThanEqual     FilterFunction = "GreaterThanEqual"
	FilterFunctionLessThan             FilterFunction = "LessThan"
	FilterFunctionLessThanEqual        FilterFunction = "LessThanEqual"
	FilterFunctionStringContains       FilterFunction = "StringContains"
	FilterFunctionStringEndsWith       FilterFunction = "StringEndsWith"
	FilterFunctionStringDoesNotContain FilterFunction = "StringDoesNotContain"
	FilterFunctionStringDoesNotEndWith FilterFunction = "StringDoesNotEndWith"
	FilterFunctionStringOneOf          FilterFunction = "StringOneOf"
	FilterFunctionStringNotOneOf       FilterFunction = "StringNotOneOf"
	FilterFunctionBetween              FilterFunction = "Between"
	FilterFunctionArrayContains        FilterFunction = "ArrayContains"
	FilterFunctionArrayDoesNotContain  FilterFunction = "ArrayDoesNotContain"
	FilterFunctionInTheLast            FilterFunction = "InTheLast"
	FilterFunctionRelativeOnOrBefore   FilterFunction = "RelativeOnOrBefore"
	FilterFunctionRelativeOnOrAfter    FilterFunction = "RelativeOnOrAfter"
	FilterFunctionStringLike           FilterFunction = "StringLike"
	FilterFunctionStringNotLike        FilterFunction = "StringNotLike"
	FilterFunctionStringMatchesTrimmed FilterFunction = "StringMatchesTrimmed"
)

func NewFilterFunctionFromString(s string) (FilterFunction, error) {
	switch s {
	case "Equality":
		return FilterFunctionEquality, nil
	case "Inequality":
		return FilterFunctionInequality, nil
	case "IsNull":
		return FilterFunctionIsNull, nil
	case "IsNotNull":
		return FilterFunctionIsNotNull, nil
	case "True":
		return FilterFunctionTrue, nil
	case "False":
		return FilterFunctionFalse, nil
	case "OnOrAfter":
		return FilterFunctionOnOrAfter, nil
	case "OnOrBefore":
		return FilterFunctionOnOrBefore, nil
	case "GreaterThan":
		return FilterFunctionGreaterThan, nil
	case "GreaterThanEqual":
		return FilterFunctionGreaterThanEqual, nil
	case "LessThan":
		return FilterFunctionLessThan, nil
	case "LessThanEqual":
		return FilterFunctionLessThanEqual, nil
	case "StringContains":
		return FilterFunctionStringContains, nil
	case "StringEndsWith":
		return FilterFunctionStringEndsWith, nil
	case "StringDoesNotContain":
		return FilterFunctionStringDoesNotContain, nil
	case "StringDoesNotEndWith":
		return FilterFunctionStringDoesNotEndWith, nil
	case "StringOneOf":
		return FilterFunctionStringOneOf, nil
	case "StringNotOneOf":
		return FilterFunctionStringNotOneOf, nil
	case "Between":
		return FilterFunctionBetween, nil
	case "ArrayContains":
		return FilterFunctionArrayContains, nil
	case "ArrayDoesNotContain":
		return FilterFunctionArrayDoesNotContain, nil
	case "InTheLast":
		return FilterFunctionInTheLast, nil
	case "RelativeOnOrBefore":
		return FilterFunctionRelativeOnOrBefore, nil
	case "RelativeOnOrAfter":
		return FilterFunctionRelativeOnOrAfter, nil
	case "StringLike":
		return FilterFunctionStringLike, nil
	case "StringNotLike":
		return FilterFunctionStringNotLike, nil
	case "StringMatchesTrimmed":
		return FilterFunctionStringMatchesTrimmed, nil
	}
	var t FilterFunction
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FilterFunction) Ptr() *FilterFunction {
	return &f
}

type GetExecutionResponseEnvelope struct {
	Data *GetExecutionResponseSchema `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetExecutionResponseEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler GetExecutionResponseEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetExecutionResponseEnvelope(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetExecutionResponseEnvelope) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetExecutionResponseSchema struct {
	CompletedAt *time.Time       `json:"completed_at,omitempty" url:"completed_at,omitempty"`
	Counts      *ExecutionCounts `json:"counts,omitempty" url:"counts,omitempty"`
	CreatedAt   *time.Time       `json:"created_at,omitempty" url:"created_at,omitempty"`
	Errors      []string         `json:"errors,omitempty" url:"errors,omitempty"`
	Id          *string          `json:"id,omitempty" url:"id,omitempty"`
	StartedAt   *time.Time       `json:"started_at,omitempty" url:"started_at,omitempty"`
	Status      *ExecutionStatus `json:"status,omitempty" url:"status,omitempty"`
	Type        *string          `json:"type,omitempty" url:"type,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetExecutionResponseSchema) UnmarshalJSON(data []byte) error {
	type embed GetExecutionResponseSchema
	var unmarshaler = struct {
		embed
		CompletedAt *core.DateTime `json:"completed_at,omitempty"`
		CreatedAt   *core.DateTime `json:"created_at,omitempty"`
		StartedAt   *core.DateTime `json:"started_at,omitempty"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GetExecutionResponseSchema(unmarshaler.embed)
	g.CompletedAt = unmarshaler.CompletedAt.TimePtr()
	g.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	g.StartedAt = unmarshaler.StartedAt.TimePtr()
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetExecutionResponseSchema) MarshalJSON() ([]byte, error) {
	type embed GetExecutionResponseSchema
	var marshaler = struct {
		embed
		CompletedAt *core.DateTime `json:"completed_at,omitempty"`
		CreatedAt   *core.DateTime `json:"created_at,omitempty"`
		StartedAt   *core.DateTime `json:"started_at,omitempty"`
	}{
		embed:       embed(*g),
		CompletedAt: core.NewOptionalDateTime(g.CompletedAt),
		CreatedAt:   core.NewOptionalDateTime(g.CreatedAt),
		StartedAt:   core.NewOptionalDateTime(g.StartedAt),
	}
	return json.Marshal(marshaler)
}

func (g *GetExecutionResponseSchema) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetModelSyncSourceMetaEnvelope struct {
	Data *ModelSyncSourceMetaResponse `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetModelSyncSourceMetaEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler GetModelSyncSourceMetaEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetModelSyncSourceMetaEnvelope(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetModelSyncSourceMetaEnvelope) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type JobResponse struct {
	Error  *string         `json:"error,omitempty" url:"error,omitempty"`
	JobId  *string         `json:"job_id,omitempty" url:"job_id,omitempty"`
	Result interface{}     `json:"result,omitempty" url:"result,omitempty"`
	Status *WorkTaskStatus `json:"status,omitempty" url:"status,omitempty"`
	Type   *string         `json:"type,omitempty" url:"type,omitempty"`

	_rawJSON json.RawMessage
}

func (j *JobResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler JobResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JobResponse(value)
	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JobResponse) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type ListBulkSchema struct {
	Data []*BulkSchema `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (l *ListBulkSchema) UnmarshalJSON(data []byte) error {
	type unmarshaler ListBulkSchema
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListBulkSchema(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListBulkSchema) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListBulkSyncExecutionStatusEnvelope struct {
	Data []*BulkSyncExecutionStatus `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (l *ListBulkSyncExecutionStatusEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler ListBulkSyncExecutionStatusEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListBulkSyncExecutionStatusEnvelope(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListBulkSyncExecutionStatusEnvelope) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListBulkSyncExecutionsEnvelope struct {
	Data []*BulkSyncExecution `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (l *ListBulkSyncExecutionsEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler ListBulkSyncExecutionsEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListBulkSyncExecutionsEnvelope(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListBulkSyncExecutionsEnvelope) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListExecutionResponseEnvelope struct {
	Data []*GetExecutionResponseSchema `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (l *ListExecutionResponseEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler ListExecutionResponseEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListExecutionResponseEnvelope(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListExecutionResponseEnvelope) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListPoliciesResponseEnvelope struct {
	Data []*PolicyResponse `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (l *ListPoliciesResponseEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler ListPoliciesResponseEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListPoliciesResponseEnvelope(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListPoliciesResponseEnvelope) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ModelField struct {
	Description *string     `json:"description,omitempty" url:"description,omitempty"`
	Example     interface{} `json:"example,omitempty" url:"example,omitempty"`
	Id          *string     `json:"id,omitempty" url:"id,omitempty"`
	Label       *string     `json:"label,omitempty" url:"label,omitempty"`
	Name        *string     `json:"name,omitempty" url:"name,omitempty"`
	RemoteType  *string     `json:"remote_type,omitempty" url:"remote_type,omitempty"`
	Type        *string     `json:"type,omitempty" url:"type,omitempty"`
	Unique      *bool       `json:"unique,omitempty" url:"unique,omitempty"`
	UserAdded   *bool       `json:"user_added,omitempty" url:"user_added,omitempty"`

	_rawJSON json.RawMessage
}

func (m *ModelField) UnmarshalJSON(data []byte) error {
	type unmarshaler ModelField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = ModelField(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *ModelField) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type ModelSyncSourceMetaResponse struct {
	Configuration map[string]*ConfigurationValue `json:"configuration,omitempty" url:"configuration,omitempty"`
	Items         map[string]*SourceMeta         `json:"items,omitempty" url:"items,omitempty"`
	RequiresOneOf []string                       `json:"requires_one_of,omitempty" url:"requires_one_of,omitempty"`

	_rawJSON json.RawMessage
}

func (m *ModelSyncSourceMetaResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ModelSyncSourceMetaResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = ModelSyncSourceMetaResponse(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *ModelSyncSourceMetaResponse) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type PickValue struct {
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	Value *string `json:"value,omitempty" url:"value,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PickValue) UnmarshalJSON(data []byte) error {
	type unmarshaler PickValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PickValue(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PickValue) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PolicyAction struct {
	Action  string   `json:"action" url:"action"`
	RoleIds []string `json:"role_ids,omitempty" url:"role_ids,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PolicyAction) UnmarshalJSON(data []byte) error {
	type unmarshaler PolicyAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PolicyAction(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PolicyAction) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PolicyResponse struct {
	Id             *string         `json:"id,omitempty" url:"id,omitempty"`
	Name           *string         `json:"name,omitempty" url:"name,omitempty"`
	OrganizationId *string         `json:"organization_id,omitempty" url:"organization_id,omitempty"`
	PolicyActions  []*PolicyAction `json:"policy_actions,omitempty" url:"policy_actions,omitempty"`
	System         *bool           `json:"system,omitempty" url:"system,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PolicyResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PolicyResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PolicyResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PolicyResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PolicyResponseEnvelope struct {
	Data *PolicyResponse `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PolicyResponseEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler PolicyResponseEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PolicyResponseEnvelope(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PolicyResponseEnvelope) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type RestErrResponse struct {
	// Application-specific error code.
	Code *int `json:"code,omitempty" url:"code,omitempty"`
	// Application context.
	Context map[string]interface{} `json:"context,omitempty" url:"context,omitempty"`
	// Error message.
	Error *string `json:"error,omitempty" url:"error,omitempty"`
	// Status text.
	Status *string `json:"status,omitempty" url:"status,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RestErrResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RestErrResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RestErrResponse(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RestErrResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RoleListResponseEnvelope struct {
	Data []*RoleResponse `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RoleListResponseEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler RoleListResponseEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RoleListResponseEnvelope(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RoleListResponseEnvelope) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RoleResponse struct {
	Id             *string `json:"id,omitempty" url:"id,omitempty"`
	Name           *string `json:"name,omitempty" url:"name,omitempty"`
	OrganizationId *string `json:"organization_id,omitempty" url:"organization_id,omitempty"`
	System         *bool   `json:"system,omitempty" url:"system,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RoleResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RoleResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RoleResponse(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RoleResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RoleResponseEnvelope struct {
	Data *RoleResponse `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RoleResponseEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler RoleResponseEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RoleResponseEnvelope(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RoleResponseEnvelope) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ScheduleFrequency string

const (
	ScheduleFrequencyManual     ScheduleFrequency = "manual"
	ScheduleFrequencyContinuous ScheduleFrequency = "continuous"
	ScheduleFrequencyHourly     ScheduleFrequency = "hourly"
	ScheduleFrequencyDaily      ScheduleFrequency = "daily"
	ScheduleFrequencyWeekly     ScheduleFrequency = "weekly"
	ScheduleFrequencyCustom     ScheduleFrequency = "custom"
	ScheduleFrequencyBuilder    ScheduleFrequency = "builder"
	ScheduleFrequencyRunafter   ScheduleFrequency = "runafter"
	ScheduleFrequencyMulti      ScheduleFrequency = "multi"
	ScheduleFrequencyDbtcloud   ScheduleFrequency = "dbtcloud"
)

func NewScheduleFrequencyFromString(s string) (ScheduleFrequency, error) {
	switch s {
	case "manual":
		return ScheduleFrequencyManual, nil
	case "continuous":
		return ScheduleFrequencyContinuous, nil
	case "hourly":
		return ScheduleFrequencyHourly, nil
	case "daily":
		return ScheduleFrequencyDaily, nil
	case "weekly":
		return ScheduleFrequencyWeekly, nil
	case "custom":
		return ScheduleFrequencyCustom, nil
	case "builder":
		return ScheduleFrequencyBuilder, nil
	case "runafter":
		return ScheduleFrequencyRunafter, nil
	case "multi":
		return ScheduleFrequencyMulti, nil
	case "dbtcloud":
		return ScheduleFrequencyDbtcloud, nil
	}
	var t ScheduleFrequency
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ScheduleFrequency) Ptr() *ScheduleFrequency {
	return &s
}

type Schema struct {
	Fields []*SchemaField `json:"fields,omitempty" url:"fields,omitempty"`
	Id     *string        `json:"id,omitempty" url:"id,omitempty"`
	Name   *string        `json:"name,omitempty" url:"name,omitempty"`

	_rawJSON json.RawMessage
}

func (s *Schema) UnmarshalJSON(data []byte) error {
	type unmarshaler Schema
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Schema(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *Schema) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SchemaAssociation struct {
	Id              *string  `json:"id,omitempty" url:"id,omitempty"`
	Name            *string  `json:"name,omitempty" url:"name,omitempty"`
	ReferenceTo     []string `json:"reference_to,omitempty" url:"reference_to,omitempty"`
	ReferencedField *string  `json:"referenced_field,omitempty" url:"referenced_field,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SchemaAssociation) UnmarshalJSON(data []byte) error {
	type unmarshaler SchemaAssociation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SchemaAssociation(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SchemaAssociation) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SchemaField struct {
	Association *SchemaAssociation `json:"association,omitempty" url:"association,omitempty"`
	Id          *string            `json:"id,omitempty" url:"id,omitempty"`
	Name        *string            `json:"name,omitempty" url:"name,omitempty"`
	// The type of the field from the remote system.
	RemoteType *string        `json:"remote_type,omitempty" url:"remote_type,omitempty"`
	Type       *UtilFieldType `json:"type,omitempty" url:"type,omitempty"`
	TypeSpec   *TypesType     `json:"type_spec,omitempty" url:"type_spec,omitempty"`
	Values     []*PickValue   `json:"values,omitempty" url:"values,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SchemaField) UnmarshalJSON(data []byte) error {
	type unmarshaler SchemaField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SchemaField(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SchemaField) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SourceMeta struct {
	HasItems      *bool         `json:"has_items,omitempty" url:"has_items,omitempty"`
	Items         []interface{} `json:"items,omitempty" url:"items,omitempty"`
	RequiresOneOf []string      `json:"requires_one_of,omitempty" url:"requires_one_of,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SourceMeta) UnmarshalJSON(data []byte) error {
	type unmarshaler SourceMeta
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SourceMeta(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SourceMeta) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SyncMode string

const (
	SyncModeCreate         SyncMode = "create"
	SyncModeUpdate         SyncMode = "update"
	SyncModeUpdateOrCreate SyncMode = "updateOrCreate"
	SyncModeReplace        SyncMode = "replace"
	SyncModeAppend         SyncMode = "append"
	SyncModeSnapshot       SyncMode = "snapshot"
	SyncModeReplicate      SyncMode = "replicate"
	SyncModeRemove         SyncMode = "remove"
)

func NewSyncModeFromString(s string) (SyncMode, error) {
	switch s {
	case "create":
		return SyncModeCreate, nil
	case "update":
		return SyncModeUpdate, nil
	case "updateOrCreate":
		return SyncModeUpdateOrCreate, nil
	case "replace":
		return SyncModeReplace, nil
	case "append":
		return SyncModeAppend, nil
	case "snapshot":
		return SyncModeSnapshot, nil
	case "replicate":
		return SyncModeReplicate, nil
	case "remove":
		return SyncModeRemove, nil
	}
	var t SyncMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SyncMode) Ptr() *SyncMode {
	return &s
}

type TypesType = interface{}

type UtilFieldType string

const (
	UtilFieldTypeUnknown  UtilFieldType = "unknown"
	UtilFieldTypeString   UtilFieldType = "string"
	UtilFieldTypeNumber   UtilFieldType = "number"
	UtilFieldTypeBoolean  UtilFieldType = "boolean"
	UtilFieldTypeDatetime UtilFieldType = "datetime"
	UtilFieldTypeArray    UtilFieldType = "array"
	UtilFieldTypeObject   UtilFieldType = "object"
	UtilFieldTypeBinary   UtilFieldType = "binary"
)

func NewUtilFieldTypeFromString(s string) (UtilFieldType, error) {
	switch s {
	case "unknown":
		return UtilFieldTypeUnknown, nil
	case "string":
		return UtilFieldTypeString, nil
	case "number":
		return UtilFieldTypeNumber, nil
	case "boolean":
		return UtilFieldTypeBoolean, nil
	case "datetime":
		return UtilFieldTypeDatetime, nil
	case "array":
		return UtilFieldTypeArray, nil
	case "object":
		return UtilFieldTypeObject, nil
	case "binary":
		return UtilFieldTypeBinary, nil
	}
	var t UtilFieldType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UtilFieldType) Ptr() *UtilFieldType {
	return &u
}

// Similar to a model configuration, this configures the enricher. For example, if you wanted to use Apollo to enrich people, you would send `{"object": "people"}` as the configuration. Each enricher configuration can be found in the connection configuration docs.
type V2EnricherConfiguration = map[string]interface{}

// A map of parent model Source Name to child model Source Name. For example, if your model has a field called `work_email` and the enricher accepts a field called `email`, you'd send a map of `{"work_email":"email"}`. The set of required input mappings varies based on the configuration of the enrichment. You can use the `enrichment/{connection_id}/inputfields` API to discover available input field combinations for a given configuration.
type V2EnricherMapping = map[string]string

type V2ExecutionLogType string

const (
	V2ExecutionLogTypeRecords  V2ExecutionLogType = "records"
	V2ExecutionLogTypeErrors   V2ExecutionLogType = "errors"
	V2ExecutionLogTypeWarnings V2ExecutionLogType = "warnings"
	V2ExecutionLogTypeInserts  V2ExecutionLogType = "inserts"
	V2ExecutionLogTypeUpdates  V2ExecutionLogType = "updates"
	V2ExecutionLogTypeDeletes  V2ExecutionLogType = "deletes"
)

func NewV2ExecutionLogTypeFromString(s string) (V2ExecutionLogType, error) {
	switch s {
	case "records":
		return V2ExecutionLogTypeRecords, nil
	case "errors":
		return V2ExecutionLogTypeErrors, nil
	case "warnings":
		return V2ExecutionLogTypeWarnings, nil
	case "inserts":
		return V2ExecutionLogTypeInserts, nil
	case "updates":
		return V2ExecutionLogTypeUpdates, nil
	case "deletes":
		return V2ExecutionLogTypeDeletes, nil
	}
	var t V2ExecutionLogType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v V2ExecutionLogType) Ptr() *V2ExecutionLogType {
	return &v
}

type V4BulkSyncExecutionLogs = map[string]interface{}

type V4BulkSyncExecutionLogsEnvelope struct {
	Data *V4BulkSyncExecutionLogs `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (v *V4BulkSyncExecutionLogsEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler V4BulkSyncExecutionLogsEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V4BulkSyncExecutionLogsEnvelope(value)
	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V4BulkSyncExecutionLogsEnvelope) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V4ExportSyncLogsEnvelope struct {
	Data *V4ExportSyncLogsResponse `json:"data,omitempty" url:"data,omitempty"`
	Job  *JobResponse              `json:"job,omitempty" url:"job,omitempty"`

	_rawJSON json.RawMessage
}

func (v *V4ExportSyncLogsEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler V4ExportSyncLogsEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V4ExportSyncLogsEnvelope(value)
	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V4ExportSyncLogsEnvelope) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V4ExportSyncLogsResponse struct {
	Url *string `json:"url,omitempty" url:"url,omitempty"`

	_rawJSON json.RawMessage
}

func (v *V4ExportSyncLogsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler V4ExportSyncLogsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V4ExportSyncLogsResponse(value)
	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V4ExportSyncLogsResponse) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type WorkTaskStatus string

const (
	WorkTaskStatusCreated WorkTaskStatus = "created"
	WorkTaskStatusRunning WorkTaskStatus = "running"
	WorkTaskStatusDone    WorkTaskStatus = "done"
	WorkTaskStatusFailed  WorkTaskStatus = "failed"
)

func NewWorkTaskStatusFromString(s string) (WorkTaskStatus, error) {
	switch s {
	case "created":
		return WorkTaskStatusCreated, nil
	case "running":
		return WorkTaskStatusRunning, nil
	case "done":
		return WorkTaskStatusDone, nil
	case "failed":
		return WorkTaskStatusFailed, nil
	}
	var t WorkTaskStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w WorkTaskStatus) Ptr() *WorkTaskStatus {
	return &w
}
