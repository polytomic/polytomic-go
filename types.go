// This file was auto-generated by Fern from our API Definition.

package polytomic

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/polytomic/polytomic-go/core"
	time "time"
)

type ActivateSyncEnvelope struct {
	Data *ActivateSyncOutput `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (a *ActivateSyncEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler ActivateSyncEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActivateSyncEnvelope(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActivateSyncEnvelope) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ActivateSyncInput struct {
	Active bool `json:"active" url:"active"`

	_rawJSON json.RawMessage
}

func (a *ActivateSyncInput) UnmarshalJSON(data []byte) error {
	type unmarshaler ActivateSyncInput
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActivateSyncInput(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActivateSyncInput) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ActivateSyncOutput struct {
	Active *bool   `json:"active,omitempty" url:"active,omitempty"`
	Id     *string `json:"id,omitempty" url:"id,omitempty"`

	_rawJSON json.RawMessage
}

func (a *ActivateSyncOutput) UnmarshalJSON(data []byte) error {
	type unmarshaler ActivateSyncOutput
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActivateSyncOutput(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActivateSyncOutput) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApiError struct {
	Key      *string                `json:"key,omitempty" url:"key,omitempty"`
	Message  *string                `json:"message,omitempty" url:"message,omitempty"`
	Metadata map[string]interface{} `json:"metadata,omitempty" url:"metadata,omitempty"`
	Status   *int                   `json:"status,omitempty" url:"status,omitempty"`

	_rawJSON json.RawMessage
}

func (a *ApiError) UnmarshalJSON(data []byte) error {
	type unmarshaler ApiError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApiError(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApiError) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type BulkBulkSyncSchedule struct {
	CreatedAt     *time.Time         `json:"createdAt,omitempty" url:"createdAt,omitempty"`
	CreatedBy     *string            `json:"createdBy,omitempty" url:"createdBy,omitempty"`
	DayOfMonth    *string            `json:"dayOfMonth,omitempty" url:"dayOfMonth,omitempty"`
	DayOfWeek     *string            `json:"dayOfWeek,omitempty" url:"dayOfWeek,omitempty"`
	DeletedAt     *time.Time         `json:"deletedAt,omitempty" url:"deletedAt,omitempty"`
	DeletedBy     *string            `json:"deletedBy,omitempty" url:"deletedBy,omitempty"`
	Frequency     ScheduleFrequency  `json:"frequency,omitempty" url:"frequency,omitempty"`
	Hour          *string            `json:"hour,omitempty" url:"hour,omitempty"`
	Minute        *string            `json:"minute,omitempty" url:"minute,omitempty"`
	Month         *string            `json:"month,omitempty" url:"month,omitempty"`
	SelectiveMode *BulkSelectiveMode `json:"selectiveMode,omitempty" url:"selectiveMode,omitempty"`
	SyncId        *string            `json:"syncId,omitempty" url:"syncId,omitempty"`
	UpdatedAt     *time.Time         `json:"updatedAt,omitempty" url:"updatedAt,omitempty"`
	UpdatedBy     *string            `json:"updatedBy,omitempty" url:"updatedBy,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BulkBulkSyncSchedule) UnmarshalJSON(data []byte) error {
	type embed BulkBulkSyncSchedule
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt,omitempty"`
		DeletedAt *core.DateTime `json:"deletedAt,omitempty"`
		UpdatedAt *core.DateTime `json:"updatedAt,omitempty"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BulkBulkSyncSchedule(unmarshaler.embed)
	b.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	b.DeletedAt = unmarshaler.DeletedAt.TimePtr()
	b.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkBulkSyncSchedule) MarshalJSON() ([]byte, error) {
	type embed BulkBulkSyncSchedule
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"createdAt,omitempty"`
		DeletedAt *core.DateTime `json:"deletedAt,omitempty"`
		UpdatedAt *core.DateTime `json:"updatedAt,omitempty"`
	}{
		embed:     embed(*b),
		CreatedAt: core.NewOptionalDateTime(b.CreatedAt),
		DeletedAt: core.NewOptionalDateTime(b.DeletedAt),
		UpdatedAt: core.NewOptionalDateTime(b.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (b *BulkBulkSyncSchedule) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BulkExecutionStatus string

const (
	BulkExecutionStatusCreated     BulkExecutionStatus = "created"
	BulkExecutionStatusScheduled   BulkExecutionStatus = "scheduled"
	BulkExecutionStatusRunning     BulkExecutionStatus = "running"
	BulkExecutionStatusExporting   BulkExecutionStatus = "exporting"
	BulkExecutionStatusCanceling   BulkExecutionStatus = "canceling"
	BulkExecutionStatusCanceled    BulkExecutionStatus = "canceled"
	BulkExecutionStatusCompleted   BulkExecutionStatus = "completed"
	BulkExecutionStatusFailed      BulkExecutionStatus = "failed"
	BulkExecutionStatusProcessing  BulkExecutionStatus = "processing"
	BulkExecutionStatusErrors      BulkExecutionStatus = "errors"
	BulkExecutionStatusInterrupted BulkExecutionStatus = "interrupted"
)

func NewBulkExecutionStatusFromString(s string) (BulkExecutionStatus, error) {
	switch s {
	case "created":
		return BulkExecutionStatusCreated, nil
	case "scheduled":
		return BulkExecutionStatusScheduled, nil
	case "running":
		return BulkExecutionStatusRunning, nil
	case "exporting":
		return BulkExecutionStatusExporting, nil
	case "canceling":
		return BulkExecutionStatusCanceling, nil
	case "canceled":
		return BulkExecutionStatusCanceled, nil
	case "completed":
		return BulkExecutionStatusCompleted, nil
	case "failed":
		return BulkExecutionStatusFailed, nil
	case "processing":
		return BulkExecutionStatusProcessing, nil
	case "errors":
		return BulkExecutionStatusErrors, nil
	case "interrupted":
		return BulkExecutionStatusInterrupted, nil
	}
	var t BulkExecutionStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BulkExecutionStatus) Ptr() *BulkExecutionStatus {
	return &b
}

// How the data is fetched. 'none' is normal operation for Polytomic. 'incremental' and 'full' apply to syncs from Salesforce. 'incremental' indicates the data is synced incrementally using record modification time. 'full' is necessary to catch up to the latest values for formula fields and rollup fields whose updates don't show up in incremental runs due to limitations in Salesforce.
type BulkFetchMode string

const (
	BulkFetchModeNone        BulkFetchMode = "none"
	BulkFetchModeIncremental BulkFetchMode = "incremental"
	BulkFetchModeFull        BulkFetchMode = "full"
)

func NewBulkFetchModeFromString(s string) (BulkFetchMode, error) {
	switch s {
	case "none":
		return BulkFetchModeNone, nil
	case "incremental":
		return BulkFetchModeIncremental, nil
	case "full":
		return BulkFetchModeFull, nil
	}
	var t BulkFetchMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BulkFetchMode) Ptr() *BulkFetchMode {
	return &b
}

type BulkField struct {
	Enabled        *bool   `json:"enabled,omitempty" url:"enabled,omitempty"`
	Id             *string `json:"id,omitempty" url:"id,omitempty"`
	Obfuscated     *bool   `json:"obfuscated,omitempty" url:"obfuscated,omitempty"`
	OutputName     *string `json:"output_name,omitempty" url:"output_name,omitempty"`
	UserOutputName *string `json:"user_output_name,omitempty" url:"user_output_name,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BulkField) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkField(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkField) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BulkFilter struct {
	// Schema field ID to filter on.
	FieldId  *string        `json:"field_id,omitempty" url:"field_id,omitempty"`
	Function FilterFunction `json:"function,omitempty" url:"function,omitempty"`
	Value    interface{}    `json:"value,omitempty" url:"value,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BulkFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkFilter(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkFilter) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BulkSchema struct {
	DataCutoffTimestamp *time.Time    `json:"data_cutoff_timestamp,omitempty" url:"data_cutoff_timestamp,omitempty"`
	DisableDataCutoff   *bool         `json:"disable_data_cutoff,omitempty" url:"disable_data_cutoff,omitempty"`
	Enabled             *bool         `json:"enabled,omitempty" url:"enabled,omitempty"`
	Fields              []*BulkField  `json:"fields,omitempty" url:"fields,omitempty"`
	Filters             []*BulkFilter `json:"filters,omitempty" url:"filters,omitempty"`
	Id                  *string       `json:"id,omitempty" url:"id,omitempty"`
	OutputName          *string       `json:"output_name,omitempty" url:"output_name,omitempty"`
	PartitionKey        *string       `json:"partition_key,omitempty" url:"partition_key,omitempty"`
	TrackingField       *string       `json:"tracking_field,omitempty" url:"tracking_field,omitempty"`
	UserOutputName      *string       `json:"user_output_name,omitempty" url:"user_output_name,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BulkSchema) UnmarshalJSON(data []byte) error {
	type embed BulkSchema
	var unmarshaler = struct {
		embed
		DataCutoffTimestamp *core.DateTime `json:"data_cutoff_timestamp,omitempty"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BulkSchema(unmarshaler.embed)
	b.DataCutoffTimestamp = unmarshaler.DataCutoffTimestamp.TimePtr()
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkSchema) MarshalJSON() ([]byte, error) {
	type embed BulkSchema
	var marshaler = struct {
		embed
		DataCutoffTimestamp *core.DateTime `json:"data_cutoff_timestamp,omitempty"`
	}{
		embed:               embed(*b),
		DataCutoffTimestamp: core.NewOptionalDateTime(b.DataCutoffTimestamp),
	}
	return json.Marshal(marshaler)
}

func (b *BulkSchema) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BulkSchemaEnvelope struct {
	Data *BulkSchema `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BulkSchemaEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkSchemaEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkSchemaEnvelope(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkSchemaEnvelope) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BulkSchemaExecutionStatus string

const (
	BulkSchemaExecutionStatusCreated     BulkSchemaExecutionStatus = "created"
	BulkSchemaExecutionStatusScheduled   BulkSchemaExecutionStatus = "scheduled"
	BulkSchemaExecutionStatusRunning     BulkSchemaExecutionStatus = "running"
	BulkSchemaExecutionStatusExporting   BulkSchemaExecutionStatus = "exporting"
	BulkSchemaExecutionStatusCanceled    BulkSchemaExecutionStatus = "canceled"
	BulkSchemaExecutionStatusCompleted   BulkSchemaExecutionStatus = "completed"
	BulkSchemaExecutionStatusFailed      BulkSchemaExecutionStatus = "failed"
	BulkSchemaExecutionStatusInterrupted BulkSchemaExecutionStatus = "interrupted"
)

func NewBulkSchemaExecutionStatusFromString(s string) (BulkSchemaExecutionStatus, error) {
	switch s {
	case "created":
		return BulkSchemaExecutionStatusCreated, nil
	case "scheduled":
		return BulkSchemaExecutionStatusScheduled, nil
	case "running":
		return BulkSchemaExecutionStatusRunning, nil
	case "exporting":
		return BulkSchemaExecutionStatusExporting, nil
	case "canceled":
		return BulkSchemaExecutionStatusCanceled, nil
	case "completed":
		return BulkSchemaExecutionStatusCompleted, nil
	case "failed":
		return BulkSchemaExecutionStatusFailed, nil
	case "interrupted":
		return BulkSchemaExecutionStatusInterrupted, nil
	}
	var t BulkSchemaExecutionStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BulkSchemaExecutionStatus) Ptr() *BulkSchemaExecutionStatus {
	return &b
}

type BulkSelectiveMode string

const (
	BulkSelectiveModeNone                 BulkSelectiveMode = "none"
	BulkSelectiveModeIncrementalFields    BulkSelectiveMode = "incrementalFields"
	BulkSelectiveModeNonincrementalFields BulkSelectiveMode = "nonincrementalFields"
)

func NewBulkSelectiveModeFromString(s string) (BulkSelectiveMode, error) {
	switch s {
	case "none":
		return BulkSelectiveModeNone, nil
	case "incrementalFields":
		return BulkSelectiveModeIncrementalFields, nil
	case "nonincrementalFields":
		return BulkSelectiveModeNonincrementalFields, nil
	}
	var t BulkSelectiveMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BulkSelectiveMode) Ptr() *BulkSelectiveMode {
	return &b
}

type BulkSyncExecution struct {
	CompletedAt   *time.Time                 `json:"completed_at,omitempty" url:"completed_at,omitempty"`
	CreatedAt     *time.Time                 `json:"created_at,omitempty" url:"created_at,omitempty"`
	ErrorCount    *int                       `json:"error_count,omitempty" url:"error_count,omitempty"`
	FetchMode     *BulkFetchMode             `json:"fetch_mode,omitempty" url:"fetch_mode,omitempty"`
	Id            *string                    `json:"id,omitempty" url:"id,omitempty"`
	IsPartial     *bool                      `json:"is_partial,omitempty" url:"is_partial,omitempty"`
	IsResync      *bool                      `json:"is_resync,omitempty" url:"is_resync,omitempty"`
	IsTest        *bool                      `json:"is_test,omitempty" url:"is_test,omitempty"`
	RecordCount   *int                       `json:"record_count,omitempty" url:"record_count,omitempty"`
	Schemas       []*BulkSyncSchemaExecution `json:"schemas,omitempty" url:"schemas,omitempty"`
	StartedAt     *time.Time                 `json:"started_at,omitempty" url:"started_at,omitempty"`
	Status        *BulkExecutionStatus       `json:"status,omitempty" url:"status,omitempty"`
	StatusMessage *string                    `json:"status_message,omitempty" url:"status_message,omitempty"`
	Type          *string                    `json:"type,omitempty" url:"type,omitempty"`
	UpdatedAt     *time.Time                 `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	WarningCount  *int                       `json:"warning_count,omitempty" url:"warning_count,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BulkSyncExecution) UnmarshalJSON(data []byte) error {
	type embed BulkSyncExecution
	var unmarshaler = struct {
		embed
		CompletedAt *core.DateTime `json:"completed_at,omitempty"`
		CreatedAt   *core.DateTime `json:"created_at,omitempty"`
		StartedAt   *core.DateTime `json:"started_at,omitempty"`
		UpdatedAt   *core.DateTime `json:"updated_at,omitempty"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BulkSyncExecution(unmarshaler.embed)
	b.CompletedAt = unmarshaler.CompletedAt.TimePtr()
	b.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	b.StartedAt = unmarshaler.StartedAt.TimePtr()
	b.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkSyncExecution) MarshalJSON() ([]byte, error) {
	type embed BulkSyncExecution
	var marshaler = struct {
		embed
		CompletedAt *core.DateTime `json:"completed_at,omitempty"`
		CreatedAt   *core.DateTime `json:"created_at,omitempty"`
		StartedAt   *core.DateTime `json:"started_at,omitempty"`
		UpdatedAt   *core.DateTime `json:"updated_at,omitempty"`
	}{
		embed:       embed(*b),
		CompletedAt: core.NewOptionalDateTime(b.CompletedAt),
		CreatedAt:   core.NewOptionalDateTime(b.CreatedAt),
		StartedAt:   core.NewOptionalDateTime(b.StartedAt),
		UpdatedAt:   core.NewOptionalDateTime(b.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (b *BulkSyncExecution) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BulkSyncExecutionEnvelope struct {
	Data *BulkSyncExecution `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BulkSyncExecutionEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler BulkSyncExecutionEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BulkSyncExecutionEnvelope(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkSyncExecutionEnvelope) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BulkSyncExecutionStatus struct {
	NextExecutionTime *time.Time                       `json:"nextExecutionTime,omitempty" url:"nextExecutionTime,omitempty"`
	Schemas           []*BulkSyncSchemaExecutionStatus `json:"schemas,omitempty" url:"schemas,omitempty"`
	Status            *BulkExecutionStatus             `json:"status,omitempty" url:"status,omitempty"`
	SyncId            *string                          `json:"sync_id,omitempty" url:"sync_id,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BulkSyncExecutionStatus) UnmarshalJSON(data []byte) error {
	type embed BulkSyncExecutionStatus
	var unmarshaler = struct {
		embed
		NextExecutionTime *core.DateTime `json:"nextExecutionTime,omitempty"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BulkSyncExecutionStatus(unmarshaler.embed)
	b.NextExecutionTime = unmarshaler.NextExecutionTime.TimePtr()
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkSyncExecutionStatus) MarshalJSON() ([]byte, error) {
	type embed BulkSyncExecutionStatus
	var marshaler = struct {
		embed
		NextExecutionTime *core.DateTime `json:"nextExecutionTime,omitempty"`
	}{
		embed:             embed(*b),
		NextExecutionTime: core.NewOptionalDateTime(b.NextExecutionTime),
	}
	return json.Marshal(marshaler)
}

func (b *BulkSyncExecutionStatus) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BulkSyncSchemaExecution struct {
	CompletedAt   *time.Time                 `json:"completed_at,omitempty" url:"completed_at,omitempty"`
	CreatedAt     *time.Time                 `json:"created_at,omitempty" url:"created_at,omitempty"`
	ErrorCount    *int                       `json:"error_count,omitempty" url:"error_count,omitempty"`
	OutputName    *string                    `json:"output_name,omitempty" url:"output_name,omitempty"`
	RecordCount   *int                       `json:"record_count,omitempty" url:"record_count,omitempty"`
	Schema        *string                    `json:"schema,omitempty" url:"schema,omitempty"`
	StartedAt     *time.Time                 `json:"started_at,omitempty" url:"started_at,omitempty"`
	Status        *BulkSchemaExecutionStatus `json:"status,omitempty" url:"status,omitempty"`
	StatusMessage *string                    `json:"status_message,omitempty" url:"status_message,omitempty"`
	UpdatedAt     *time.Time                 `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	WarningCount  *int                       `json:"warning_count,omitempty" url:"warning_count,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BulkSyncSchemaExecution) UnmarshalJSON(data []byte) error {
	type embed BulkSyncSchemaExecution
	var unmarshaler = struct {
		embed
		CompletedAt *core.DateTime `json:"completed_at,omitempty"`
		CreatedAt   *core.DateTime `json:"created_at,omitempty"`
		StartedAt   *core.DateTime `json:"started_at,omitempty"`
		UpdatedAt   *core.DateTime `json:"updated_at,omitempty"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BulkSyncSchemaExecution(unmarshaler.embed)
	b.CompletedAt = unmarshaler.CompletedAt.TimePtr()
	b.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	b.StartedAt = unmarshaler.StartedAt.TimePtr()
	b.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkSyncSchemaExecution) MarshalJSON() ([]byte, error) {
	type embed BulkSyncSchemaExecution
	var marshaler = struct {
		embed
		CompletedAt *core.DateTime `json:"completed_at,omitempty"`
		CreatedAt   *core.DateTime `json:"created_at,omitempty"`
		StartedAt   *core.DateTime `json:"started_at,omitempty"`
		UpdatedAt   *core.DateTime `json:"updated_at,omitempty"`
	}{
		embed:       embed(*b),
		CompletedAt: core.NewOptionalDateTime(b.CompletedAt),
		CreatedAt:   core.NewOptionalDateTime(b.CreatedAt),
		StartedAt:   core.NewOptionalDateTime(b.StartedAt),
		UpdatedAt:   core.NewOptionalDateTime(b.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (b *BulkSyncSchemaExecution) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BulkSyncSchemaExecutionStatus struct {
	CompletedAt *time.Time `json:"completed_at,omitempty" url:"completed_at,omitempty"`
	ErrorCount  *int       `json:"error_count,omitempty" url:"error_count,omitempty"`
	// ID of the most recent execution for the schema.
	ExecutionId   *string                    `json:"execution_id,omitempty" url:"execution_id,omitempty"`
	RecordCount   *int                       `json:"record_count,omitempty" url:"record_count,omitempty"`
	Schema        *string                    `json:"schema,omitempty" url:"schema,omitempty"`
	StartedAt     *time.Time                 `json:"started_at,omitempty" url:"started_at,omitempty"`
	Status        *BulkSchemaExecutionStatus `json:"status,omitempty" url:"status,omitempty"`
	StatusMessage *string                    `json:"status_message,omitempty" url:"status_message,omitempty"`
	WarningCount  *int                       `json:"warning_count,omitempty" url:"warning_count,omitempty"`

	_rawJSON json.RawMessage
}

func (b *BulkSyncSchemaExecutionStatus) UnmarshalJSON(data []byte) error {
	type embed BulkSyncSchemaExecutionStatus
	var unmarshaler = struct {
		embed
		CompletedAt *core.DateTime `json:"completed_at,omitempty"`
		StartedAt   *core.DateTime `json:"started_at,omitempty"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BulkSyncSchemaExecutionStatus(unmarshaler.embed)
	b.CompletedAt = unmarshaler.CompletedAt.TimePtr()
	b.StartedAt = unmarshaler.StartedAt.TimePtr()
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BulkSyncSchemaExecutionStatus) MarshalJSON() ([]byte, error) {
	type embed BulkSyncSchemaExecutionStatus
	var marshaler = struct {
		embed
		CompletedAt *core.DateTime `json:"completed_at,omitempty"`
		StartedAt   *core.DateTime `json:"started_at,omitempty"`
	}{
		embed:       embed(*b),
		CompletedAt: core.NewOptionalDateTime(b.CompletedAt),
		StartedAt:   core.NewOptionalDateTime(b.StartedAt),
	}
	return json.Marshal(marshaler)
}

func (b *BulkSyncSchemaExecutionStatus) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type CommonOutputActor struct {
	Id   *string `json:"id,omitempty" url:"id,omitempty"`
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	Type *string `json:"type,omitempty" url:"type,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CommonOutputActor) UnmarshalJSON(data []byte) error {
	type unmarshaler CommonOutputActor
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CommonOutputActor(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CommonOutputActor) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConfigurationValue struct {
	Items []interface{} `json:"items,omitempty" url:"items,omitempty"`
	Type  *string       `json:"type,omitempty" url:"type,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ConfigurationValue) UnmarshalJSON(data []byte) error {
	type unmarshaler ConfigurationValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConfigurationValue(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConfigurationValue) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConnectionMeta struct {
	HasItems      *bool         `json:"has_items,omitempty" url:"has_items,omitempty"`
	Items         []interface{} `json:"items,omitempty" url:"items,omitempty"`
	RequiresOneOf []string      `json:"requires_one_of,omitempty" url:"requires_one_of,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ConnectionMeta) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectionMeta
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectionMeta(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionMeta) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConnectionMetaResponse struct {
	Configuration map[string]*ConfigurationValue `json:"configuration,omitempty" url:"configuration,omitempty"`
	Items         map[string]*ConnectionMeta     `json:"items,omitempty" url:"items,omitempty"`
	RequiresOneOf []string                       `json:"requires_one_of,omitempty" url:"requires_one_of,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ConnectionMetaResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectionMetaResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectionMetaResponse(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectionMetaResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ExecutionCounts struct {
	Delete   *int `json:"delete,omitempty" url:"delete,omitempty"`
	Error    *int `json:"error,omitempty" url:"error,omitempty"`
	Insert   *int `json:"insert,omitempty" url:"insert,omitempty"`
	Total    *int `json:"total,omitempty" url:"total,omitempty"`
	Update   *int `json:"update,omitempty" url:"update,omitempty"`
	Upserts  *int `json:"upserts,omitempty" url:"upserts,omitempty"`
	Warnings *int `json:"warnings,omitempty" url:"warnings,omitempty"`

	_rawJSON json.RawMessage
}

func (e *ExecutionCounts) UnmarshalJSON(data []byte) error {
	type unmarshaler ExecutionCounts
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExecutionCounts(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ExecutionCounts) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExecutionLogResponse struct {
	Expires *time.Time `json:"expires,omitempty" url:"expires,omitempty"`
	Urls    []string   `json:"urls,omitempty" url:"urls,omitempty"`

	_rawJSON json.RawMessage
}

func (e *ExecutionLogResponse) UnmarshalJSON(data []byte) error {
	type embed ExecutionLogResponse
	var unmarshaler = struct {
		embed
		Expires *core.DateTime `json:"expires,omitempty"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = ExecutionLogResponse(unmarshaler.embed)
	e.Expires = unmarshaler.Expires.TimePtr()
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ExecutionLogResponse) MarshalJSON() ([]byte, error) {
	type embed ExecutionLogResponse
	var marshaler = struct {
		embed
		Expires *core.DateTime `json:"expires,omitempty"`
	}{
		embed:   embed(*e),
		Expires: core.NewOptionalDateTime(e.Expires),
	}
	return json.Marshal(marshaler)
}

func (e *ExecutionLogResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExecutionLogsResponseEnvelope struct {
	Data *ExecutionLogResponse `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (e *ExecutionLogsResponseEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler ExecutionLogsResponseEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExecutionLogsResponseEnvelope(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ExecutionLogsResponseEnvelope) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExecutionStatus string

const (
	ExecutionStatusCreated     ExecutionStatus = "created"
	ExecutionStatusScheduled   ExecutionStatus = "scheduled"
	ExecutionStatusQueued      ExecutionStatus = "queued"
	ExecutionStatusWaiting     ExecutionStatus = "waiting"
	ExecutionStatusRunning     ExecutionStatus = "running"
	ExecutionStatusProcessing  ExecutionStatus = "processing"
	ExecutionStatusCanceling   ExecutionStatus = "canceling"
	ExecutionStatusCanceled    ExecutionStatus = "canceled"
	ExecutionStatusCompleted   ExecutionStatus = "completed"
	ExecutionStatusFailed      ExecutionStatus = "failed"
	ExecutionStatusInterrupted ExecutionStatus = "interrupted"
)

func NewExecutionStatusFromString(s string) (ExecutionStatus, error) {
	switch s {
	case "created":
		return ExecutionStatusCreated, nil
	case "scheduled":
		return ExecutionStatusScheduled, nil
	case "queued":
		return ExecutionStatusQueued, nil
	case "waiting":
		return ExecutionStatusWaiting, nil
	case "running":
		return ExecutionStatusRunning, nil
	case "processing":
		return ExecutionStatusProcessing, nil
	case "canceling":
		return ExecutionStatusCanceling, nil
	case "canceled":
		return ExecutionStatusCanceled, nil
	case "completed":
		return ExecutionStatusCompleted, nil
	case "failed":
		return ExecutionStatusFailed, nil
	case "interrupted":
		return ExecutionStatusInterrupted, nil
	}
	var t ExecutionStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e ExecutionStatus) Ptr() *ExecutionStatus {
	return &e
}

type FilterFunction string

const (
	FilterFunctionEquality               FilterFunction = "Equality"
	FilterFunctionInequality             FilterFunction = "Inequality"
	FilterFunctionIsNull                 FilterFunction = "IsNull"
	FilterFunctionIsNotNull              FilterFunction = "IsNotNull"
	FilterFunctionTrue                   FilterFunction = "True"
	FilterFunctionFalse                  FilterFunction = "False"
	FilterFunctionOnOrAfter              FilterFunction = "OnOrAfter"
	FilterFunctionOnOrBefore             FilterFunction = "OnOrBefore"
	FilterFunctionGreaterThan            FilterFunction = "GreaterThan"
	FilterFunctionGreaterThanEqual       FilterFunction = "GreaterThanEqual"
	FilterFunctionLessThan               FilterFunction = "LessThan"
	FilterFunctionLessThanEqual          FilterFunction = "LessThanEqual"
	FilterFunctionStringContains         FilterFunction = "StringContains"
	FilterFunctionStringStartsWith       FilterFunction = "StringStartsWith"
	FilterFunctionStringEndsWith         FilterFunction = "StringEndsWith"
	FilterFunctionStringDoesNotContain   FilterFunction = "StringDoesNotContain"
	FilterFunctionStringDoesNotStartWith FilterFunction = "StringDoesNotStartWith"
	FilterFunctionStringDoesNotEndWith   FilterFunction = "StringDoesNotEndWith"
	FilterFunctionStringOneOf            FilterFunction = "StringOneOf"
	FilterFunctionStringNotOneOf         FilterFunction = "StringNotOneOf"
	FilterFunctionBetween                FilterFunction = "Between"
	FilterFunctionArrayContains          FilterFunction = "ArrayContains"
	FilterFunctionArrayDoesNotContain    FilterFunction = "ArrayDoesNotContain"
	FilterFunctionInTheLast              FilterFunction = "InTheLast"
	FilterFunctionRelativeOnOrBefore     FilterFunction = "RelativeOnOrBefore"
	FilterFunctionRelativeOnOrAfter      FilterFunction = "RelativeOnOrAfter"
	FilterFunctionStringLike             FilterFunction = "StringLike"
	FilterFunctionStringNotLike          FilterFunction = "StringNotLike"
	FilterFunctionStringMatchesTrimmed   FilterFunction = "StringMatchesTrimmed"
)

func NewFilterFunctionFromString(s string) (FilterFunction, error) {
	switch s {
	case "Equality":
		return FilterFunctionEquality, nil
	case "Inequality":
		return FilterFunctionInequality, nil
	case "IsNull":
		return FilterFunctionIsNull, nil
	case "IsNotNull":
		return FilterFunctionIsNotNull, nil
	case "True":
		return FilterFunctionTrue, nil
	case "False":
		return FilterFunctionFalse, nil
	case "OnOrAfter":
		return FilterFunctionOnOrAfter, nil
	case "OnOrBefore":
		return FilterFunctionOnOrBefore, nil
	case "GreaterThan":
		return FilterFunctionGreaterThan, nil
	case "GreaterThanEqual":
		return FilterFunctionGreaterThanEqual, nil
	case "LessThan":
		return FilterFunctionLessThan, nil
	case "LessThanEqual":
		return FilterFunctionLessThanEqual, nil
	case "StringContains":
		return FilterFunctionStringContains, nil
	case "StringStartsWith":
		return FilterFunctionStringStartsWith, nil
	case "StringEndsWith":
		return FilterFunctionStringEndsWith, nil
	case "StringDoesNotContain":
		return FilterFunctionStringDoesNotContain, nil
	case "StringDoesNotStartWith":
		return FilterFunctionStringDoesNotStartWith, nil
	case "StringDoesNotEndWith":
		return FilterFunctionStringDoesNotEndWith, nil
	case "StringOneOf":
		return FilterFunctionStringOneOf, nil
	case "StringNotOneOf":
		return FilterFunctionStringNotOneOf, nil
	case "Between":
		return FilterFunctionBetween, nil
	case "ArrayContains":
		return FilterFunctionArrayContains, nil
	case "ArrayDoesNotContain":
		return FilterFunctionArrayDoesNotContain, nil
	case "InTheLast":
		return FilterFunctionInTheLast, nil
	case "RelativeOnOrBefore":
		return FilterFunctionRelativeOnOrBefore, nil
	case "RelativeOnOrAfter":
		return FilterFunctionRelativeOnOrAfter, nil
	case "StringLike":
		return FilterFunctionStringLike, nil
	case "StringNotLike":
		return FilterFunctionStringNotLike, nil
	case "StringMatchesTrimmed":
		return FilterFunctionStringMatchesTrimmed, nil
	}
	var t FilterFunction
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FilterFunction) Ptr() *FilterFunction {
	return &f
}

type GetConnectionMetaEnvelope struct {
	Data *ConnectionMetaResponse `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetConnectionMetaEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler GetConnectionMetaEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetConnectionMetaEnvelope(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetConnectionMetaEnvelope) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetExecutionResponseEnvelope struct {
	Data *GetExecutionResponseSchema `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetExecutionResponseEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler GetExecutionResponseEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetExecutionResponseEnvelope(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetExecutionResponseEnvelope) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetExecutionResponseSchema struct {
	CompletedAt *time.Time       `json:"completed_at,omitempty" url:"completed_at,omitempty"`
	Counts      *ExecutionCounts `json:"counts,omitempty" url:"counts,omitempty"`
	CreatedAt   *time.Time       `json:"created_at,omitempty" url:"created_at,omitempty"`
	Errors      []string         `json:"errors,omitempty" url:"errors,omitempty"`
	Id          *string          `json:"id,omitempty" url:"id,omitempty"`
	StartedAt   *time.Time       `json:"started_at,omitempty" url:"started_at,omitempty"`
	Status      *ExecutionStatus `json:"status,omitempty" url:"status,omitempty"`
	Type        *string          `json:"type,omitempty" url:"type,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetExecutionResponseSchema) UnmarshalJSON(data []byte) error {
	type embed GetExecutionResponseSchema
	var unmarshaler = struct {
		embed
		CompletedAt *core.DateTime `json:"completed_at,omitempty"`
		CreatedAt   *core.DateTime `json:"created_at,omitempty"`
		StartedAt   *core.DateTime `json:"started_at,omitempty"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GetExecutionResponseSchema(unmarshaler.embed)
	g.CompletedAt = unmarshaler.CompletedAt.TimePtr()
	g.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	g.StartedAt = unmarshaler.StartedAt.TimePtr()
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetExecutionResponseSchema) MarshalJSON() ([]byte, error) {
	type embed GetExecutionResponseSchema
	var marshaler = struct {
		embed
		CompletedAt *core.DateTime `json:"completed_at,omitempty"`
		CreatedAt   *core.DateTime `json:"created_at,omitempty"`
		StartedAt   *core.DateTime `json:"started_at,omitempty"`
	}{
		embed:       embed(*g),
		CompletedAt: core.NewOptionalDateTime(g.CompletedAt),
		CreatedAt:   core.NewOptionalDateTime(g.CreatedAt),
		StartedAt:   core.NewOptionalDateTime(g.StartedAt),
	}
	return json.Marshal(marshaler)
}

func (g *GetExecutionResponseSchema) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetModelSyncSourceMetaEnvelope struct {
	Data *ModelSyncSourceMetaResponse `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetModelSyncSourceMetaEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler GetModelSyncSourceMetaEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetModelSyncSourceMetaEnvelope(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetModelSyncSourceMetaEnvelope) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type IdentityFunction struct {
	Id    *string `json:"id,omitempty" url:"id,omitempty"`
	Label *string `json:"label,omitempty" url:"label,omitempty"`

	_rawJSON json.RawMessage
}

func (i *IdentityFunction) UnmarshalJSON(data []byte) error {
	type unmarshaler IdentityFunction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IdentityFunction(value)
	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IdentityFunction) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type JobResponse struct {
	Error  *string         `json:"error,omitempty" url:"error,omitempty"`
	JobId  *string         `json:"job_id,omitempty" url:"job_id,omitempty"`
	Result interface{}     `json:"result,omitempty" url:"result,omitempty"`
	Status *WorkTaskStatus `json:"status,omitempty" url:"status,omitempty"`
	Type   *string         `json:"type,omitempty" url:"type,omitempty"`

	_rawJSON json.RawMessage
}

func (j *JobResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler JobResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*j = JobResponse(value)
	j._rawJSON = json.RawMessage(data)
	return nil
}

func (j *JobResponse) String() string {
	if len(j._rawJSON) > 0 {
		if value, err := core.StringifyJSON(j._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(j); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", j)
}

type ListBulkSchema struct {
	Data []*BulkSchema `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (l *ListBulkSchema) UnmarshalJSON(data []byte) error {
	type unmarshaler ListBulkSchema
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListBulkSchema(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListBulkSchema) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListBulkSyncExecutionStatusEnvelope struct {
	Data []*BulkSyncExecutionStatus `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (l *ListBulkSyncExecutionStatusEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler ListBulkSyncExecutionStatusEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListBulkSyncExecutionStatusEnvelope(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListBulkSyncExecutionStatusEnvelope) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListBulkSyncExecutionsEnvelope struct {
	Data       []*BulkSyncExecution `json:"data,omitempty" url:"data,omitempty"`
	Pagination *PaginationDetails   `json:"pagination,omitempty" url:"pagination,omitempty"`

	_rawJSON json.RawMessage
}

func (l *ListBulkSyncExecutionsEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler ListBulkSyncExecutionsEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListBulkSyncExecutionsEnvelope(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListBulkSyncExecutionsEnvelope) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListExecutionResponseEnvelope struct {
	Data       []*GetExecutionResponseSchema `json:"data,omitempty" url:"data,omitempty"`
	Pagination *PaginationDetails            `json:"pagination,omitempty" url:"pagination,omitempty"`

	_rawJSON json.RawMessage
}

func (l *ListExecutionResponseEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler ListExecutionResponseEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListExecutionResponseEnvelope(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListExecutionResponseEnvelope) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListPoliciesResponseEnvelope struct {
	Data []*PolicyResponse `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (l *ListPoliciesResponseEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler ListPoliciesResponseEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListPoliciesResponseEnvelope(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListPoliciesResponseEnvelope) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type Mode struct {
	Description           *string `json:"description,omitempty" url:"description,omitempty"`
	Label                 *string `json:"label,omitempty" url:"label,omitempty"`
	Mode                  *string `json:"mode,omitempty" url:"mode,omitempty"`
	RequiresIdentity      *bool   `json:"requires_identity,omitempty" url:"requires_identity,omitempty"`
	SupportsFieldSyncMode *bool   `json:"supports_field_sync_mode,omitempty" url:"supports_field_sync_mode,omitempty"`
	SupportsTargetFilters *bool   `json:"supports_target_filters,omitempty" url:"supports_target_filters,omitempty"`

	_rawJSON json.RawMessage
}

func (m *Mode) UnmarshalJSON(data []byte) error {
	type unmarshaler Mode
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Mode(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *Mode) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type ModelField struct {
	CreatedAt   *time.Time         `json:"created_at,omitempty" url:"created_at,omitempty"`
	CreatedBy   *CommonOutputActor `json:"created_by,omitempty" url:"created_by,omitempty"`
	Description *string            `json:"description,omitempty" url:"description,omitempty"`
	Example     interface{}        `json:"example,omitempty" url:"example,omitempty"`
	Id          *string            `json:"id,omitempty" url:"id,omitempty"`
	Label       *string            `json:"label,omitempty" url:"label,omitempty"`
	Name        *string            `json:"name,omitempty" url:"name,omitempty"`
	RemoteType  *string            `json:"remote_type,omitempty" url:"remote_type,omitempty"`
	Type        *string            `json:"type,omitempty" url:"type,omitempty"`
	Unique      *bool              `json:"unique,omitempty" url:"unique,omitempty"`
	UpdatedAt   *time.Time         `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	UserAdded   *bool              `json:"user_added,omitempty" url:"user_added,omitempty"`

	_rawJSON json.RawMessage
}

func (m *ModelField) UnmarshalJSON(data []byte) error {
	type embed ModelField
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at,omitempty"`
		UpdatedAt *core.DateTime `json:"updated_at,omitempty"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = ModelField(unmarshaler.embed)
	m.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	m.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *ModelField) MarshalJSON() ([]byte, error) {
	type embed ModelField
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at,omitempty"`
		UpdatedAt *core.DateTime `json:"updated_at,omitempty"`
	}{
		embed:     embed(*m),
		CreatedAt: core.NewOptionalDateTime(m.CreatedAt),
		UpdatedAt: core.NewOptionalDateTime(m.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (m *ModelField) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type ModelSyncMode string

const (
	ModelSyncModeCreate         ModelSyncMode = "create"
	ModelSyncModeUpdate         ModelSyncMode = "update"
	ModelSyncModeUpdateOrCreate ModelSyncMode = "updateOrCreate"
	ModelSyncModeReplace        ModelSyncMode = "replace"
	ModelSyncModeAppend         ModelSyncMode = "append"
	ModelSyncModeRemove         ModelSyncMode = "remove"
)

func NewModelSyncModeFromString(s string) (ModelSyncMode, error) {
	switch s {
	case "create":
		return ModelSyncModeCreate, nil
	case "update":
		return ModelSyncModeUpdate, nil
	case "updateOrCreate":
		return ModelSyncModeUpdateOrCreate, nil
	case "replace":
		return ModelSyncModeReplace, nil
	case "append":
		return ModelSyncModeAppend, nil
	case "remove":
		return ModelSyncModeRemove, nil
	}
	var t ModelSyncMode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m ModelSyncMode) Ptr() *ModelSyncMode {
	return &m
}

type ModelSyncSourceMetaResponse struct {
	Configuration map[string]*ConfigurationValue `json:"configuration,omitempty" url:"configuration,omitempty"`
	Items         map[string]*SourceMeta         `json:"items,omitempty" url:"items,omitempty"`
	RequiresOneOf []string                       `json:"requires_one_of,omitempty" url:"requires_one_of,omitempty"`

	_rawJSON json.RawMessage
}

func (m *ModelSyncSourceMetaResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ModelSyncSourceMetaResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = ModelSyncSourceMetaResponse(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *ModelSyncSourceMetaResponse) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type PaginationDetails struct {
	NextPageToken *string `json:"next_page_token,omitempty" url:"next_page_token,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PaginationDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginationDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginationDetails(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginationDetails) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PickValue struct {
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	Value *string `json:"value,omitempty" url:"value,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PickValue) UnmarshalJSON(data []byte) error {
	type unmarshaler PickValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PickValue(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PickValue) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PolicyAction struct {
	Action  string   `json:"action" url:"action"`
	RoleIds []string `json:"role_ids,omitempty" url:"role_ids,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PolicyAction) UnmarshalJSON(data []byte) error {
	type unmarshaler PolicyAction
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PolicyAction(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PolicyAction) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PolicyResponse struct {
	Id             *string         `json:"id,omitempty" url:"id,omitempty"`
	Name           *string         `json:"name,omitempty" url:"name,omitempty"`
	OrganizationId *string         `json:"organization_id,omitempty" url:"organization_id,omitempty"`
	PolicyActions  []*PolicyAction `json:"policy_actions,omitempty" url:"policy_actions,omitempty"`
	System         *bool           `json:"system,omitempty" url:"system,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PolicyResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PolicyResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PolicyResponse(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PolicyResponse) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PolicyResponseEnvelope struct {
	Data *PolicyResponse `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PolicyResponseEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler PolicyResponseEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PolicyResponseEnvelope(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PolicyResponseEnvelope) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type RestErrResponse struct {
	// Application-specific error code.
	Code *int `json:"code,omitempty" url:"code,omitempty"`
	// Application context.
	Context map[string]interface{} `json:"context,omitempty" url:"context,omitempty"`
	// Error message.
	Error *string `json:"error,omitempty" url:"error,omitempty"`
	// Status text.
	Status *string `json:"status,omitempty" url:"status,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RestErrResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RestErrResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RestErrResponse(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RestErrResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RoleListResponseEnvelope struct {
	Data []*RoleResponse `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RoleListResponseEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler RoleListResponseEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RoleListResponseEnvelope(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RoleListResponseEnvelope) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RoleResponse struct {
	Id             *string `json:"id,omitempty" url:"id,omitempty"`
	Name           *string `json:"name,omitempty" url:"name,omitempty"`
	OrganizationId *string `json:"organization_id,omitempty" url:"organization_id,omitempty"`
	System         *bool   `json:"system,omitempty" url:"system,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RoleResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RoleResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RoleResponse(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RoleResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RoleResponseEnvelope struct {
	Data *RoleResponse `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RoleResponseEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler RoleResponseEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RoleResponseEnvelope(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RoleResponseEnvelope) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ScheduleEnvelope struct {
	Data *BulkBulkSyncSchedule `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (s *ScheduleEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler ScheduleEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ScheduleEnvelope(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *ScheduleEnvelope) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type ScheduleFrequency string

const (
	ScheduleFrequencyManual     ScheduleFrequency = "manual"
	ScheduleFrequencyContinuous ScheduleFrequency = "continuous"
	ScheduleFrequencyHourly     ScheduleFrequency = "hourly"
	ScheduleFrequencyDaily      ScheduleFrequency = "daily"
	ScheduleFrequencyWeekly     ScheduleFrequency = "weekly"
	ScheduleFrequencyCustom     ScheduleFrequency = "custom"
	ScheduleFrequencyBuilder    ScheduleFrequency = "builder"
	ScheduleFrequencyRunafter   ScheduleFrequency = "runafter"
	ScheduleFrequencyMulti      ScheduleFrequency = "multi"
	ScheduleFrequencyDbtcloud   ScheduleFrequency = "dbtcloud"
)

func NewScheduleFrequencyFromString(s string) (ScheduleFrequency, error) {
	switch s {
	case "manual":
		return ScheduleFrequencyManual, nil
	case "continuous":
		return ScheduleFrequencyContinuous, nil
	case "hourly":
		return ScheduleFrequencyHourly, nil
	case "daily":
		return ScheduleFrequencyDaily, nil
	case "weekly":
		return ScheduleFrequencyWeekly, nil
	case "custom":
		return ScheduleFrequencyCustom, nil
	case "builder":
		return ScheduleFrequencyBuilder, nil
	case "runafter":
		return ScheduleFrequencyRunafter, nil
	case "multi":
		return ScheduleFrequencyMulti, nil
	case "dbtcloud":
		return ScheduleFrequencyDbtcloud, nil
	}
	var t ScheduleFrequency
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ScheduleFrequency) Ptr() *ScheduleFrequency {
	return &s
}

type SchedulesEnvelope struct {
	Data []*BulkBulkSyncSchedule `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SchedulesEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler SchedulesEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SchedulesEnvelope(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SchedulesEnvelope) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type Schema struct {
	Fields []*SchemaField `json:"fields,omitempty" url:"fields,omitempty"`
	Id     *string        `json:"id,omitempty" url:"id,omitempty"`
	Name   *string        `json:"name,omitempty" url:"name,omitempty"`

	_rawJSON json.RawMessage
}

func (s *Schema) UnmarshalJSON(data []byte) error {
	type unmarshaler Schema
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Schema(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *Schema) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SchemaAssociation struct {
	Id              *string  `json:"id,omitempty" url:"id,omitempty"`
	Name            *string  `json:"name,omitempty" url:"name,omitempty"`
	ReferenceTo     []string `json:"reference_to,omitempty" url:"reference_to,omitempty"`
	ReferencedField *string  `json:"referenced_field,omitempty" url:"referenced_field,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SchemaAssociation) UnmarshalJSON(data []byte) error {
	type unmarshaler SchemaAssociation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SchemaAssociation(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SchemaAssociation) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SchemaField struct {
	Association *SchemaAssociation `json:"association,omitempty" url:"association,omitempty"`
	Id          *string            `json:"id,omitempty" url:"id,omitempty"`
	Name        *string            `json:"name,omitempty" url:"name,omitempty"`
	// The type of the field from the remote system.
	RemoteType *string        `json:"remote_type,omitempty" url:"remote_type,omitempty"`
	Type       *UtilFieldType `json:"type,omitempty" url:"type,omitempty"`
	TypeSpec   *TypesType     `json:"type_spec,omitempty" url:"type_spec,omitempty"`
	Values     []*PickValue   `json:"values,omitempty" url:"values,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SchemaField) UnmarshalJSON(data []byte) error {
	type unmarshaler SchemaField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SchemaField(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SchemaField) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SourceMeta struct {
	HasItems      *bool         `json:"has_items,omitempty" url:"has_items,omitempty"`
	Items         []interface{} `json:"items,omitempty" url:"items,omitempty"`
	RequiresOneOf []string      `json:"requires_one_of,omitempty" url:"requires_one_of,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SourceMeta) UnmarshalJSON(data []byte) error {
	type unmarshaler SourceMeta
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SourceMeta(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SourceMeta) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SupportedMode struct {
	Id *ModelSyncMode `json:"id,omitempty" url:"id,omitempty"`
	// True if the sync mode requires an identity field mapping.
	RequiresIdentity *bool `json:"requires_identity,omitempty" url:"requires_identity,omitempty"`
	// True if the target supports per-field sync modes.
	SupportsPerFieldMode *bool `json:"supports_per_field_mode,omitempty" url:"supports_per_field_mode,omitempty"`
	// True if the sync mode supports target filters.
	SupportsTargetFilters *bool `json:"supports_target_filters,omitempty" url:"supports_target_filters,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SupportedMode) UnmarshalJSON(data []byte) error {
	type unmarshaler SupportedMode
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SupportedMode(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SupportedMode) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SyncDestinationProperties struct {
	DoesNotReportOperationCounts  *bool   `json:"does_not_report_operation_counts,omitempty" url:"does_not_report_operation_counts,omitempty"`
	MappingsNotRequired           *bool   `json:"mappings_not_required,omitempty" url:"mappings_not_required,omitempty"`
	NewTargetLabel                *string `json:"new_target_label,omitempty" url:"new_target_label,omitempty"`
	OptionalTargetMappings        *bool   `json:"optional_target_mappings,omitempty" url:"optional_target_mappings,omitempty"`
	PrimaryMetadataObject         *string `json:"primary_metadata_object,omitempty" url:"primary_metadata_object,omitempty"`
	RequiresConfiguration         *bool   `json:"requires_configuration,omitempty" url:"requires_configuration,omitempty"`
	SupportsFieldCreation         *bool   `json:"supports_field_creation,omitempty" url:"supports_field_creation,omitempty"`
	SupportsFieldEncryption       *bool   `json:"supports_field_encryption,omitempty" url:"supports_field_encryption,omitempty"`
	SupportsFieldTypeSelection    *bool   `json:"supports_field_type_selection,omitempty" url:"supports_field_type_selection,omitempty"`
	SupportsIdentityFieldCreation *bool   `json:"supports_identity_field_creation,omitempty" url:"supports_identity_field_creation,omitempty"`
	SupportsTargetFilters         *bool   `json:"supports_target_filters,omitempty" url:"supports_target_filters,omitempty"`
	TargetCreator                 *bool   `json:"target_creator,omitempty" url:"target_creator,omitempty"`
	UseFieldNamesAsLabels         *bool   `json:"use_field_names_as_labels,omitempty" url:"use_field_names_as_labels,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SyncDestinationProperties) UnmarshalJSON(data []byte) error {
	type unmarshaler SyncDestinationProperties
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SyncDestinationProperties(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SyncDestinationProperties) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type TargetCreateInput struct {
	// True if the property is an enum.
	Enum *bool `json:"enum,omitempty" url:"enum,omitempty"`
	// The identifier of the target property.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// A human readable title for the target property.
	Title *string `json:"title,omitempty" url:"title,omitempty"`

	_rawJSON json.RawMessage
}

func (t *TargetCreateInput) UnmarshalJSON(data []byte) error {
	type unmarshaler TargetCreateInput
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TargetCreateInput(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TargetCreateInput) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TargetField struct {
	Association       *bool               `json:"association,omitempty" url:"association,omitempty"`
	Createable        *bool               `json:"createable,omitempty" url:"createable,omitempty"`
	Description       *string             `json:"description,omitempty" url:"description,omitempty"`
	Encryptable       *bool               `json:"encryptable,omitempty" url:"encryptable,omitempty"`
	Filterable        *bool               `json:"filterable,omitempty" url:"filterable,omitempty"`
	Id                *string             `json:"id,omitempty" url:"id,omitempty"`
	IdentityFunctions []*IdentityFunction `json:"identity_functions,omitempty" url:"identity_functions,omitempty"`
	Name              *string             `json:"name,omitempty" url:"name,omitempty"`
	Required          *bool               `json:"required,omitempty" url:"required,omitempty"`
	SourceType        *string             `json:"source_type,omitempty" url:"source_type,omitempty"`
	SupportsIdentity  *bool               `json:"supports_identity,omitempty" url:"supports_identity,omitempty"`
	Type              *string             `json:"type,omitempty" url:"type,omitempty"`
	Updateable        *bool               `json:"updateable,omitempty" url:"updateable,omitempty"`

	_rawJSON json.RawMessage
}

func (t *TargetField) UnmarshalJSON(data []byte) error {
	type unmarshaler TargetField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TargetField(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TargetField) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TargetObject struct {
	// The identifier of the target object.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The supported sync modes and their properties for the target object.
	Modes []*SupportedMode `json:"modes,omitempty" url:"modes,omitempty"`
	// The name of the target object.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	_rawJSON json.RawMessage
}

func (t *TargetObject) UnmarshalJSON(data []byte) error {
	type unmarshaler TargetObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TargetObject(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TargetObject) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TargetResponse struct {
	Fields      []*TargetField             `json:"fields,omitempty" url:"fields,omitempty"`
	Id          *string                    `json:"id,omitempty" url:"id,omitempty"`
	Modes       []*Mode                    `json:"modes,omitempty" url:"modes,omitempty"`
	Name        *string                    `json:"name,omitempty" url:"name,omitempty"`
	Properties  *SyncDestinationProperties `json:"properties,omitempty" url:"properties,omitempty"`
	RefreshedAt *time.Time                 `json:"refreshed_at,omitempty" url:"refreshed_at,omitempty"`

	_rawJSON json.RawMessage
}

func (t *TargetResponse) UnmarshalJSON(data []byte) error {
	type embed TargetResponse
	var unmarshaler = struct {
		embed
		RefreshedAt *core.DateTime `json:"refreshed_at,omitempty"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TargetResponse(unmarshaler.embed)
	t.RefreshedAt = unmarshaler.RefreshedAt.TimePtr()
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TargetResponse) MarshalJSON() ([]byte, error) {
	type embed TargetResponse
	var marshaler = struct {
		embed
		RefreshedAt *core.DateTime `json:"refreshed_at,omitempty"`
	}{
		embed:       embed(*t),
		RefreshedAt: core.NewOptionalDateTime(t.RefreshedAt),
	}
	return json.Marshal(marshaler)
}

func (t *TargetResponse) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TargetResponseEnvelope struct {
	Data *TargetResponse `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (t *TargetResponseEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler TargetResponseEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TargetResponseEnvelope(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TargetResponseEnvelope) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TypesType = interface{}

type UpdateBulkField struct {
	Enabled        *bool   `json:"enabled,omitempty" url:"enabled,omitempty"`
	Id             *string `json:"id,omitempty" url:"id,omitempty"`
	Obfuscated     *bool   `json:"obfuscated,omitempty" url:"obfuscated,omitempty"`
	UserOutputName *string `json:"user_output_name,omitempty" url:"user_output_name,omitempty"`

	_rawJSON json.RawMessage
}

func (u *UpdateBulkField) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateBulkField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateBulkField(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateBulkField) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UtilEnumValue struct {
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	Value *string `json:"value,omitempty" url:"value,omitempty"`

	_rawJSON json.RawMessage
}

func (u *UtilEnumValue) UnmarshalJSON(data []byte) error {
	type unmarshaler UtilEnumValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UtilEnumValue(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UtilEnumValue) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UtilFieldType string

const (
	UtilFieldTypeUnknown  UtilFieldType = "unknown"
	UtilFieldTypeString   UtilFieldType = "string"
	UtilFieldTypeNumber   UtilFieldType = "number"
	UtilFieldTypeBoolean  UtilFieldType = "boolean"
	UtilFieldTypeDatetime UtilFieldType = "datetime"
	UtilFieldTypeArray    UtilFieldType = "array"
	UtilFieldTypeObject   UtilFieldType = "object"
	UtilFieldTypeBinary   UtilFieldType = "binary"
)

func NewUtilFieldTypeFromString(s string) (UtilFieldType, error) {
	switch s {
	case "unknown":
		return UtilFieldTypeUnknown, nil
	case "string":
		return UtilFieldTypeString, nil
	case "number":
		return UtilFieldTypeNumber, nil
	case "boolean":
		return UtilFieldTypeBoolean, nil
	case "datetime":
		return UtilFieldTypeDatetime, nil
	case "array":
		return UtilFieldTypeArray, nil
	case "object":
		return UtilFieldTypeObject, nil
	case "binary":
		return UtilFieldTypeBinary, nil
	}
	var t UtilFieldType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UtilFieldType) Ptr() *UtilFieldType {
	return &u
}

type V2ExecutionLogType string

const (
	V2ExecutionLogTypeRecords  V2ExecutionLogType = "records"
	V2ExecutionLogTypeErrors   V2ExecutionLogType = "errors"
	V2ExecutionLogTypeWarnings V2ExecutionLogType = "warnings"
	V2ExecutionLogTypeInserts  V2ExecutionLogType = "inserts"
	V2ExecutionLogTypeUpdates  V2ExecutionLogType = "updates"
	V2ExecutionLogTypeDeletes  V2ExecutionLogType = "deletes"
)

func NewV2ExecutionLogTypeFromString(s string) (V2ExecutionLogType, error) {
	switch s {
	case "records":
		return V2ExecutionLogTypeRecords, nil
	case "errors":
		return V2ExecutionLogTypeErrors, nil
	case "warnings":
		return V2ExecutionLogTypeWarnings, nil
	case "inserts":
		return V2ExecutionLogTypeInserts, nil
	case "updates":
		return V2ExecutionLogTypeUpdates, nil
	case "deletes":
		return V2ExecutionLogTypeDeletes, nil
	}
	var t V2ExecutionLogType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v V2ExecutionLogType) Ptr() *V2ExecutionLogType {
	return &v
}

type V4BulkSyncExecutionLogs = map[string]interface{}

type V4BulkSyncExecutionLogsEnvelope struct {
	Data *V4BulkSyncExecutionLogs `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (v *V4BulkSyncExecutionLogsEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler V4BulkSyncExecutionLogsEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V4BulkSyncExecutionLogsEnvelope(value)
	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V4BulkSyncExecutionLogsEnvelope) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V4BulkSyncScheduleApi struct {
	DayOfMonth    *string            `json:"dayOfMonth,omitempty" url:"dayOfMonth,omitempty"`
	DayOfWeek     *string            `json:"dayOfWeek,omitempty" url:"dayOfWeek,omitempty"`
	Frequency     ScheduleFrequency  `json:"frequency,omitempty" url:"frequency,omitempty"`
	Hour          *string            `json:"hour,omitempty" url:"hour,omitempty"`
	Minute        *string            `json:"minute,omitempty" url:"minute,omitempty"`
	Month         *string            `json:"month,omitempty" url:"month,omitempty"`
	SelectiveMode *BulkSelectiveMode `json:"selectiveMode,omitempty" url:"selectiveMode,omitempty"`

	_rawJSON json.RawMessage
}

func (v *V4BulkSyncScheduleApi) UnmarshalJSON(data []byte) error {
	type unmarshaler V4BulkSyncScheduleApi
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V4BulkSyncScheduleApi(value)
	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V4BulkSyncScheduleApi) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V4ExportSyncLogsEnvelope struct {
	Data *V4ExportSyncLogsResponse `json:"data,omitempty" url:"data,omitempty"`
	Job  *JobResponse              `json:"job,omitempty" url:"job,omitempty"`

	_rawJSON json.RawMessage
}

func (v *V4ExportSyncLogsEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler V4ExportSyncLogsEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V4ExportSyncLogsEnvelope(value)
	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V4ExportSyncLogsEnvelope) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V4ExportSyncLogsResponse struct {
	Url *string `json:"url,omitempty" url:"url,omitempty"`

	_rawJSON json.RawMessage
}

func (v *V4ExportSyncLogsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler V4ExportSyncLogsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V4ExportSyncLogsResponse(value)
	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V4ExportSyncLogsResponse) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V4TargetCreator struct {
	// The properties that are required for target creation.
	Properties []*TargetCreateInput `json:"properties,omitempty" url:"properties,omitempty"`
	// True if the connection supports target creation.
	Supported *bool `json:"supported,omitempty" url:"supported,omitempty"`

	_rawJSON json.RawMessage
}

func (v *V4TargetCreator) UnmarshalJSON(data []byte) error {
	type unmarshaler V4TargetCreator
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V4TargetCreator(value)
	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V4TargetCreator) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V4TargetObjectsResponseEnvelope struct {
	Data           []*TargetObject  `json:"data,omitempty" url:"data,omitempty"`
	TargetCreation *V4TargetCreator `json:"target_creation,omitempty" url:"target_creation,omitempty"`

	_rawJSON json.RawMessage
}

func (v *V4TargetObjectsResponseEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler V4TargetObjectsResponseEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V4TargetObjectsResponseEnvelope(value)
	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V4TargetObjectsResponseEnvelope) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V4TargetPropertyValues struct {
	// True if the property is an enum.
	Enum *bool `json:"enum,omitempty" url:"enum,omitempty"`
	// The identifier of the target property.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// A human readable title for the target property.
	Title *string `json:"title,omitempty" url:"title,omitempty"`
	// Valid values for the target property.
	Values []*UtilEnumValue `json:"values,omitempty" url:"values,omitempty"`

	_rawJSON json.RawMessage
}

func (v *V4TargetPropertyValues) UnmarshalJSON(data []byte) error {
	type unmarshaler V4TargetPropertyValues
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V4TargetPropertyValues(value)
	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V4TargetPropertyValues) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type V4TargetPropertyValuesEnvelope struct {
	Data *V4TargetPropertyValues `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (v *V4TargetPropertyValuesEnvelope) UnmarshalJSON(data []byte) error {
	type unmarshaler V4TargetPropertyValuesEnvelope
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = V4TargetPropertyValuesEnvelope(value)
	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *V4TargetPropertyValuesEnvelope) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type WorkTaskStatus string

const (
	WorkTaskStatusCreated WorkTaskStatus = "created"
	WorkTaskStatusRunning WorkTaskStatus = "running"
	WorkTaskStatusDone    WorkTaskStatus = "done"
	WorkTaskStatusFailed  WorkTaskStatus = "failed"
)

func NewWorkTaskStatusFromString(s string) (WorkTaskStatus, error) {
	switch s {
	case "created":
		return WorkTaskStatusCreated, nil
	case "running":
		return WorkTaskStatusRunning, nil
	case "done":
		return WorkTaskStatusDone, nil
	case "failed":
		return WorkTaskStatusFailed, nil
	}
	var t WorkTaskStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w WorkTaskStatus) Ptr() *WorkTaskStatus {
	return &w
}
